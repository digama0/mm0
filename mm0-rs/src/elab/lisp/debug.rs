//! Debug formatting for mm0-rs items that works around indirection.
//!
//! Meant to be used in conjunction with a FormatEnv struct. Can be used
//! with the `{:?}` format specifier as in the following example:
//!```
//! // let fe = FormatEnv { source: &text, env };
//! // let thm : Thm = /* some theorem */;
//! // println!("{:?}", fe.to(&thm));
//!```
//!
//! Implementations for native rust types and mm0-rs types that do not use indirection
//! are generated by macro_rules macros. Implementations for indirect mm0-rs types 
//! are generated by the EnvDebug and EnvDebugPub macros

use shoebill::{ Printer, Doclike, DocPtr };
use shoebill::ron::{ RonStruct, RonSequence, RonTuple, RonOption, RonResult };
use super::{print::FormatEnv, super::environment::{AtomID, SortID, TermID, ThmID} };

/// Companion to `EnvDisplay`
pub trait EnvDebug {
  /// Get the actual debug representation. It's highly unlikely you'll
  /// need to call this outside of another EnvDebug implementation.
  fn env_dbg<'a>(&self, fe : FormatEnv<'a>, p : &mut Printer<'a>) -> DocPtr<'a>;
}


// For types external to mm0-rs, generate an instance of EnvDebug that just returns its default
// std::fmt::Debug representation as a DocPtr.
macro_rules! env_debug {
  ( $($xs:ty),+ ) => {
    $(
      impl EnvDebug for $xs {
        fn env_dbg<'__a>(&self, _ : FormatEnv<'__a>, p : &mut Printer<'__a>) -> shoebill::DocPtr<'__a> {
          format!("{:#?}", self).alloc(p)
        }
      }
    )+
  };
}

// Generate an implementation for any sequence whose `self.iter()` method has an associated
// Item type that implements EnvDebug.
// Type parameters need to be in a comma separated list that's surrounded by parens.
macro_rules! env_debug_seq {
  ( $( ($($id:ident),+) -> $T:ty )+ ) => {
    $(
      impl<$($id: EnvDebug),+> EnvDebug for $T {
        fn env_dbg<'__a>(&self, fe : FormatEnv<'__a>, p : &mut Printer<'__a>) -> shoebill::DocPtr<'__a> {
          let mut ron = RonSequence::new();
          for elem in self.iter() {
            ron.add_field(elem.env_dbg(fe, p));
          }
          ron.to_doc(p)
        }
      }
    )+
  };
}

// Generate an implementation for any map type whose `self.iter()` method has an associated
// Item which is a (&K, &V), where the K and V types both implement EnvDebug.
// Type parameters need to be in a comma separated list that's surrounded by parens.
macro_rules! env_debug_map {
  ( $( ($($id:ident),+) -> $T:ty )+ ) => {
    $(
      impl<$($id: EnvDebug),+> EnvDebug for $T {
        fn env_dbg<'__a>(&self, fe : FormatEnv<'__a>, p : &mut Printer<'__a>) -> shoebill::DocPtr<'__a> {
          let mut ron = RonStruct::new();
          for (k, v) in self.iter() {
            ron.add_field(k.env_dbg(fe, p), v.env_dbg(fe, p));
          }
          ron.to_doc(p)
        }
      }
    )+
  };
}

// Generate an implementation for some type whose AsRef target implements EnvDebug, like Box<A>.
// Type parameters need to be in a comma separated list that's surrounded by parens.
macro_rules! env_debug_as_ref {
  ( $( ($($id:ident),+) -> $T:ty )+ ) => {
    $(
      impl<$($id: EnvDebug),+> EnvDebug for $T {
        fn env_dbg<'__a>(&self, fe : FormatEnv<'__a>, p : &mut Printer<'__a>) -> shoebill::DocPtr<'__a> {
          self.as_ref().env_dbg(fe, p)
        }
      }
    )+
  };
}


// Generate implementations of EnvDebug for arrays of a type that implements EnvDebug.
macro_rules! dbg_arrays {
  ($($N:literal)+) => {
    $(
      impl<A : EnvDebug> EnvDebug for [A; $N] {
        fn env_dbg<'__a>(&self, fe : FormatEnv<'__a>, p : &mut Printer<'__a>) -> shoebill::DocPtr<'__a> {
          self.as_ref().env_dbg(fe, p)
        }
      }
    )+
  }
}

// Generate implementations of EnvDebug for tuples with type parameters that implement EnvDebug.
macro_rules! dbg_tuples {
  ($( { $( ($idx:tt) -> $T:ident)+ } )+) => { 
    $(
       impl<$($T : EnvDebug),+> EnvDebug for ($($T),+) {
         fn env_dbg<'__a>(&self, fe : FormatEnv<'__a>, p : &mut Printer<'__a>) -> shoebill::DocPtr<'__a> {
           let mut ron = RonTuple::new();
           $(ron.add_field(self.$idx.env_dbg(fe, p));)+
           ron.to_doc(p)
         }
       }
    )+
  }
}

// Generate implementations for SortID, ThmID, TermID. 
macro_rules! env_debug_id {
  ( $(($x:ident, $loc:ident))+ ) => {
    $(
      impl EnvDebug for $x {
        fn env_dbg<'__a>(&self, fe : FormatEnv<'__a>, p : &mut Printer<'__a>) -> shoebill::DocPtr<'__a> {
          let mut ron = RonTuple::new();
          ron.add_name(stringify!($x));
          match self {
            $x(idx) => { ron.add_field(idx.env_dbg(fe, p)); }
          }

          let atom_id = &fe.$loc[*self].atom;
          let atom_data = &fe.data[*atom_id];
          ron.add_field(atom_data.name.env_dbg(fe, p));
          ron.to_doc(p)
        }
      }
    )+
  };
}


// Instances for a few common types that require some sort of special behavior to display nicely.
impl<A : EnvDebug> EnvDebug for std::cell::RefCell<A> {
  fn env_dbg<'a>(
    &self, 
    fe : FormatEnv<'a>,
    p : &mut Printer<'a>, 
  ) -> DocPtr<'a> {
    match self.try_borrow() {
      Ok(x) => x.env_dbg(fe, p),
      Err(_) => "_mutably borrowed RefCell_".alloc(p)
    }
  }
}

impl<A : EnvDebug, E : EnvDebug> EnvDebug for Result<A, E> {
  fn env_dbg<'a>(&self, fe : FormatEnv<'a>, p : &mut Printer<'a>) -> DocPtr<'a> {
    let ron = RonResult::new(
      self.as_ref().map(|x| x.env_dbg(fe, p)).map_err(|e| e.env_dbg(fe, p))
    );
    ron.to_doc(p)
  }
}

impl<A : EnvDebug> EnvDebug for Option<A> {
  fn env_dbg<'a>(&self, fe : FormatEnv<'a>, p : &mut Printer<'a>) -> DocPtr<'a> {
    let inner = self.as_ref().map(|a| a.env_dbg(fe, p));
    RonOption::new(inner).to_doc(p)
  }
}

impl<A : EnvDebug> EnvDebug for std::sync::Arc<A> {
  fn env_dbg<'a>(&self, fe : FormatEnv<'a>, p : &mut Printer<'a>) -> DocPtr<'a> {
    std::sync::Arc::as_ref(self).env_dbg(fe, p)
  }
}

impl<A : EnvDebug> EnvDebug for std::rc::Rc<A> {
  fn env_dbg<'a>(&self, fe : FormatEnv<'a>, p : &mut Printer<'a>) -> DocPtr<'a> {
    std::rc::Rc::as_ref(self).env_dbg(fe, p)
  }
}

// Needs a separate implementation since it doesn't have
// an `atom` field, and the others don't have `name` field.
impl EnvDebug for AtomID {
  fn env_dbg<'__a>(&self, fe : FormatEnv<'__a>, p : &mut Printer<'__a>) -> shoebill::DocPtr<'__a> {
    let mut ron = RonTuple::new();
    ron.add_name("AtomID");
    match self {
      AtomID(idx) => { ron.add_field(idx.env_dbg(fe, p)); }
    }
    ron.add_field(fe.data[*self].name.env_dbg(fe, p));
    ron.to_doc(p)
  }
}

env_debug! {
  bool,
  u8,
  u16,
  u32,
  u64,
  usize,
  i8,
  i16,
  i32,
  i64,
  isize,
  f32,
  f64,
  &str,
  String,
  std::path::PathBuf,
  std::sync::atomic::AtomicBool,
  crate::util::ArcString,
  crate::elab::lisp::Syntax,
  crate::mmc::types::Keyword,
  crate::mmc::types::ProcKind,
  crate::mmc::nameck::GlobalTC,
  crate::mmc::nameck::PrimType,
  crate::mmc::nameck::ProcTC,
  crate::elab::lisp::BuiltinProc,
  crate::elab::lisp::ProcSpec,
  crate::parser::ast::Prec,
  crate::elab::environment::Literal,
  crate::parser::ast::Modifiers,
  crate::util::Span,
  crate::util::FileRef,
  crate::util::FileSpan,
  lsp_types::Url
}

env_debug_seq! {
  (A) -> &[A]
  (A) -> Vec<A>
}

env_debug_map! {
  (K, V) -> std::collections::HashMap<K, V>
}

env_debug_as_ref! {
  (A) -> Box<A>
  (A) -> Box<[A]>
}

dbg_arrays! {
     0  1  2  3  4  5  6  7  8  9
    10 11 12 13 14 15 16 17 18 19
    20 21 22 23 24 25 26 27 28 29
    30 31 32
}

dbg_tuples! { 
  { 
    (0) -> A
    (1) -> B
  }
  { 
    (0) -> A
    (1) -> B
    (2) -> C
  }
  { 
    (0) -> A
    (1) -> B
    (2) -> C
    (3) -> D
  }
  { 
    (0) -> A
    (1) -> B
    (2) -> C
    (3) -> D
    (4) -> E
  }
  { 
    (0) -> A
    (1) -> B
    (2) -> C
    (3) -> D
    (4) -> E
    (5) -> F
  }
  { 
    (0) -> A
    (1) -> B
    (2) -> C
    (3) -> D
    (4) -> E
    (5) -> F
    (6) -> G
  }
  { 
    (0) -> A
    (1) -> B
    (2) -> C
    (3) -> D
    (4) -> E
    (5) -> F
    (6) -> G
    (7) -> H
  }
  { 
    (0) -> A
    (1) -> B
    (2) -> C
    (3) -> D
    (4) -> E
    (5) -> F
    (6) -> G
    (7) -> H
    (8) -> I
  }
}

env_debug_id! {
  (SortID, sorts)
  (ThmID, thms)
  (TermID, terms)
}
