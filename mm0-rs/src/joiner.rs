//! Join MM1/MM0 files with imports by concatenation
//!
//! This module implements a very simple import-by-text-inclusion method to allow us to have
//! `import` statements in MM0 files, even though the `import` command is not officially part
//! of MM0 and is not supported by the `mm0-c` verifier. This is essentially the same as
//! the textual inclusion used by the C `#include` preprocessor directive. In order to use
//! a file like [`mm0.mm0`], which is an MM0 file with an `import`, you have to first call
//!
//!     mm0-rs join mm0.mm0 mm0_join.mm0
//!
//! and it will create `mm0_join.mm0` by inserting the text of `peano.mm0` at the location
//! of the `import "peano.mm0";` statement. The resulting file will be a proper MM0 file and
//! can be run through the `mm0-c` verifier and other conforming verifiers.
//!
//! [`mm0.mm0`]: https://github.com/digama0/mm0/blob/master/examples/mm0.mm0
use std::collections::HashSet;
use std::fs;
use std::io::{self, Write};
use std::path::PathBuf;
use std::sync::Arc;
use clap::ArgMatches;
use crate::util::FileRef;
use crate::lined_string::LinedString;
use crate::parser::{parse, ast::StmtKind};

/// Running data for the file join process.
struct Joiner<W: Write> {
  /// True if we should add auxiliary comments
  comments: bool,
  /// The current stack of file references, to reify the recursive process of
  /// following `import` directives. This lets us check for import cycles.
  stack: Vec<FileRef>,
  /// The set of files that have already been output or are currently being output.
  /// A file that has been output will not be printed again if another `import`
  /// for the same file is declared.
  /// This means that in a diamond dependence `A -> {B, C} -> D`, `A` will not be
  /// printed twice (once before `B` and once before `C`).
  working: HashSet<FileRef>,
  /// The list of files that were output, in post-order traversal.
  done: Vec<FileRef>,
  /// The writer to print the output file to
  w: W,
}

impl<W: Write> Joiner<W> {
  /// Create a new `Joiner` from a writer.
  fn new(comments: bool, w: W) -> Self {
    Self {comments, stack: vec![], working: HashSet::new(), done: vec![], w}
  }

  /// Write the file at `path` to `self.w`, following all imports recursively.
  fn write(&mut self, path: FileRef) -> io::Result<()> {
    if let Some(i) = self.stack.iter().rposition(|x| x == &path) {
      self.stack.push(path);
      panic!("import cycle: {:?}", &self.stack[i..])
    }
    self.stack.push(path.clone());
    let src = Arc::<LinedString>::new(fs::read_to_string(path.path())?.into());
    let (_, ast) = parse(src.clone(), None);
    let mut start = 0;
    for s in &ast.stmts {
      if let StmtKind::Import(_, f) = &s.k {
        let f = std::str::from_utf8(f).map_err(|_|
          io::Error::new(io::ErrorKind::InvalidInput, "invalid utf8"))?;
        let r: FileRef = path.path().parent()
          .map_or_else(|| PathBuf::from(f), |p| p.join(f))
          .canonicalize()?.into();
        self.w.write_all(&src.as_bytes()[start..s.span.start])?;
        if self.working.insert(r.clone()) {
          self.write(r)?;
          if self.comments {
            self.w.write_all(&[b'\n'])?;
          }
        }
        start = s.span.end;
      }
    }
    if self.comments {
      write!(self.w, "{}\n-- {} --\n{0}\n",
        // Safety: '-' is utf8
        unsafe { String::from_utf8_unchecked(vec![b'-'; path.rel().len() + 6]) },
        path.rel())?;
    }
    self.w.write_all(&src.as_bytes()[start..])?;
    self.stack.pop();
    self.done.push(path);
    Ok(())
  }
}

fn join_with_header(comments: bool, header: bool, mut w: impl Write, file: FileRef) -> io::Result<()> {
  let mut buf = vec![];
  if comments && header {
    let mut joiner = Joiner::new(comments, &mut buf);
    joiner.write(file.clone())?;
    writeln!(w, "\
      -- This is an autogenerated file constructed by `mm0-rs join {}`.\n\
      -- It concatenates the files:", file)?;
    for p in joiner.done { writeln!(w, "-- * {}", p)? }
    writeln!(w)?;
    w.write_all(&buf)
  } else {
    Joiner::new(comments, w).write(file)
  }
}

/// Main entry point for `mm0-rs join` subcommand.
///
/// See the [module documentation] for the purpose of this command.
///
/// # Arguments
///
/// `mm0-rs join <in.mm0> [out.mm0]`, where:
///
/// - `in.mm0` (or `in.mm1`) is the file to join, an MM0 file with `import`s
/// - `out.mm0` is the output location, or stdin if omitted.
///
/// [module documentation]: index.html
pub fn main(args: &ArgMatches<'_>) -> io::Result<()> {
  let path = args.value_of("INPUT").expect("required arg");
  let file = fs::canonicalize(path)?.into();
  let comments = !args.is_present("bare");
  let header = !args.is_present("no_header");
  match args.value_of("OUTPUT") {
    None => join_with_header(comments, header, io::stdout(), file),
    Some(out) => join_with_header(comments, header, fs::File::create(out)?, file),
  }
}