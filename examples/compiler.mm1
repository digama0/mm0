import "separation_logic.mm1";

@_ local def X86P_Input = $ b0 0 $;
@_ local def X86P_Output = $ b0 1 $;
@_ local def X86P_Except = $ b0 2 $;
@_ local def X86P_RIP = $ b0 3 $;
@_ local def X86P_Flags = $ b0 4 $;
@_ local def X86P_Virtual (n: nat) = $ b0 (suc (suc (suc (suc (suc n))))) $;
@_ local def X86P_Reg (n: nat) = $ b1 (b0 n) $;
@_ local def X86P_Mem (n: nat) = $ b1 (b1 n) $;

@_ local def read_place (ks: nat): set =
$ case
    (ocase (ksIn ks)
      (ocase (ksOut ks)
        (ocase (readException (ksCfg ks))
          (ocase (readRIP (ksCfg ks))
            (ocase (readFlags (ksCfg ks))
              0)))))
    (case
      (\ r, readReg (ksCfg ks) r)
      (\ a, getMemory (ksCfg ks) @ a <> ksMapping ks @ a)) $;

theorem read_place_Input: $ read_place ks @ X86P_Input = ksIn ks $ =
(named '(eqtr casel ocase0));
theorem read_place_Output: $ read_place ks @ X86P_Output = ksOut ks $ =
(named '(eqtr casel @ eqtr ocaseS ocase0));
theorem read_place_Except: $ read_place ks @ X86P_Except = readException (ksCfg ks) $ =
(named '(eqtr casel @ eqtr ocaseS @ eqtr ocaseS ocase0));
theorem read_place_RIP: $ read_place ks @ X86P_RIP = readRIP (ksCfg ks) $ =
(named '(eqtr casel ,(iterate 3 (fn (x) '(eqtr ocaseS ,x)) 'ocase0)));
theorem read_place_Flags: $ read_place ks @ X86P_Flags = readFlags (ksCfg ks) $ =
(named '(eqtr casel ,(iterate 4 (fn (x) '(eqtr ocaseS ,x)) 'ocase0)));
theorem read_place_Virtual: $ read_place ks @ X86P_Virtual n = 0 $ =
(named '(eqtr casel ,(iterate 5 (fn (x) '(eqtr ocaseS ,x)) 'app01)));
theorem read_place_Reg: $ read_place ks @ X86P_Reg r = readReg (ksCfg ks) r $ =
(named '(eqtr caser @ eqtr casel @ applame ,eqtac));
theorem read_place_Mem: $ read_place ks @ X86P_Mem a = getMemory (ksCfg ks) @ a <> ksMapping ks @ a $ =
(named '(eqtr caser @ eqtr caser @ applame ,eqtac));

theorem read_place_setMemory_ne: $ ~E. a p = X86P_Mem a ->
  read_place (setCfg ks (setMemory (ksCfg ks) m)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_Except$ => ,(h 'read_place_Except 'readExceptioneq 'readException_setMemory)) o
     ($X86P_RIP$ => ,(h 'read_place_RIP 'readRIPeq 'readRIP_setMemory)) o
     ($X86P_Flags$ => ,(h 'read_place_Flags 'readFlagseq 'readFlags_setMemory)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ => ,(h 'read_place_Reg 'readRegeq1 'readReg_setMemory)) +
     ($X86P_Mem n$ => (impcom @ syl absurdr @ iexe ,eqtac))}});
theorem read_place_setMemory_eq:
  $ read_place (setCfg ks (setMemory (ksCfg ks) m)) @ X86P_Mem a = m @ a <> ksMapping ks @ a $ =
'(eqtr read_place_Mem @
  preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) get_setMemory) @
  appneq1 ksMapping_setCfg);

theorem read_place_setException_ne: $ p != X86P_Except ->
  read_place (setCfg ks (setException (ksCfg ks) e)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_Except$ => (imp absurd)) o
     ($X86P_RIP$ => ,(h 'read_place_RIP 'readRIPeq 'readRIP_setException)) o
     ($X86P_Flags$ => ,(h 'read_place_Flags 'readFlagseq 'readFlags_setException)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ => ,(h 'read_place_Reg 'readRegeq1 'readReg_setException)) +
     ($X86P_Mem n$ => ,(g 'read_place_Mem
      '(preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) getMemory_setException) @
        appneq1 ksMapping_setCfg)))}});

theorem read_place_writeFlags_ne: $ p != X86P_Flags ->
  read_place (setCfg ks (writeFlags (ksCfg ks) v)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_Except$ => ,(h 'read_place_Except 'readExceptioneq 'readException_writeFlags)) o
     ($X86P_RIP$ => ,(h 'read_place_RIP 'readRIPeq 'readRIP_writeFlags)) o
     ($X86P_Flags$ => (imp absurd)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ => ,(h 'read_place_Reg 'readRegeq1 'readReg_writeFlags)) +
     ($X86P_Mem n$ => ,(g 'read_place_Mem
      '(preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) getMemory_writeFlags) @
        appneq1 ksMapping_setCfg)))}});

theorem read_place_writeRIP_ne: $ p != X86P_RIP ->
  read_place (setCfg ks (writeRIP (ksCfg ks) v)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_Except$ => ,(h 'read_place_Except 'readExceptioneq 'readException_writeRIP)) o
     ($X86P_RIP$ => (imp absurd)) o
     ($X86P_Flags$ => ,(h 'read_place_Flags 'readFlagseq 'readFlags_writeRIP)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ => ,(h 'read_place_Reg 'readRegeq1 'readReg_writeRIP)) +
     ($X86P_Mem n$ => ,(g 'read_place_Mem
      '(preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) getMemory_writeRIP) @
        appneq1 ksMapping_setCfg)))}});

theorem read_place_setReg_ne: $ p != X86P_Reg r ->
  read_place (setCfg ks (setReg (ksCfg ks) r q)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_Except$ => ,(h 'read_place_Except 'readExceptioneq 'readException_setReg)) o
     ($X86P_RIP$ => ,(h 'read_place_RIP 'readRIPeq 'readRIP_setReg)) o
     ($X86P_Flags$ => ,(h 'read_place_Flags 'readFlagseq 'readFlags_setReg)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ =>
      (impcom @ mpbiri (sylbi (noteq @ bitr b1can b0can) @
          eqtr4g read_place_Reg read_place_Reg @
          syl5eq (readRegeq1 ksCfg_setCfg) read_setReg_ne)
        ,eqtac)) +
     ($X86P_Mem n$ => ,(g 'read_place_Mem
      '(preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) getMemory_setReg) @
        appneq1 ksMapping_setCfg)))}});

@_ local def XBlock_Reg (n: nat) = $ b0 (b0 n) $;
@_ local def XBlock_Mem (a len: nat) = $ b0 (b1 (a <> len)) $;
@_ local def XBlock_Const (val: nat) = $ b1 val $;

@_ local def MSize = $ 0 ; 8 ; 16 ; 32 ; sn 64 $;
@_ local def MSize_bytes (sz: nat) = $ sz // 8 $;

@_ local def heap_sat (k h: nat): wff =
$ isfun h /\ k e. KernelState /\ A. p A. x (p <> x e. h -> read_place k @ p = x) $;
infixl heap_sat: $|=h$ prec 50;

theorem heap_sat_isf: $ k |=h h -> isfun h $ = (named 'anll);
theorem heap_sat_ks: $ k |=h h -> k e. KernelState $ = (named 'anlr);

theorem heap_sat_02: $ k e. KernelState -> k |=h 0 $ =
(named '(iand (ian isf0) @ a1i @ ax_gen @ ax_gen @ absurd el02));

theorem heap_sat_sn: $ k |=h sn (p <> x) <-> k e. KernelState /\ read_place k @ p = x $ =
'(aneq (bian1 isfsn) @ bitr (aleqi @ bitr (aleqi @
    bitr (imeq1i @ bitr elsn prth) impexp) alim1) @
  aleqe @ syl5bb (aleqe ,eqtac) ,eqtac);

theorem heap_sat_E: $ k |=h h /\ p <> x e. h -> read_place k @ p = x $ =
'(impcom @ syl5 anr @ com12 @ ealie @ ealde @ bi1d ,eqtac);

@_ local def s_sat (k: nat) (P: set): wff = $ E. h (h e. P /\ k |=h h) $;
infixl s_sat: $|=s$ prec 50;
theorem s_sat_antop: $ k |=s P /\s T.s <-> k |=s P $ =
(named '(exeqi @ aneq1a @ syl5bb el_s_antop @ syl bian1 heap_sat_isf));
theorem s_sat_ks: $ k |=s P -> k e. KernelState $ = (named '(eex @ anwr heap_sat_ks));
theorem s_sat_bot: $ ~k |=s F.s $ = (named '(nexi @ mt anl el_s_bot));
theorem s_sat_emp: $ k e. KernelState -> k |=s emp $ =
(named '(sylibr (exeqi @ aneq1i el_s_emp) @ sylibr (exeqe heap_sateq2) heap_sat_02));
theorem s_sat_sep_emp1: $ k |=s emp *s P <-> k |=s P $ = '(bitr (s_sateq2 s_sep_emp1a) s_sat_antop);

theorem s_elConfig_d: $ G /\ ksCfg ks = k /\ ks |=s P -> k e. Config $ =
'(mpbid (eleq1d anlr) (anwr @ syl ksCfgT s_sat_ks));

theorem s_sat_sep_sn: $ k |=s R *s P <-> E. r (r e. R /\ k |=s sn r *s P) $ =
(named '(bitr4 (exeqi ancomb) @ bitr (rexeqi @ exeqi ancomb) @
  bitr4 rexcomb @ rexeqi @ bitr4 el_s_sep2 @ rexeqi el_s_sep_sn1));

theorem s_sat_sn: $ k |=s sn h <-> k |=h h $ =
'(bitr (exeqi @ aneq1i elsn) @ exeqe ,eqtac);

theorem s_sat_ex (P: set x): $ k |=s E.s x e. A, P <-> E. x (x e. A /\ k |=s P) $ =
(named '(bitr4 (exeqi @ bitr4 (aneq1i el_s_ex) rexan2) rexexcomb));

theorem s_sat_anlift1: $ k |=s ^s p /\s P <-> p /\ k |=s P $ =
(named '(bitr (exeqi @ bitr (aneq1a @
    syl5bb el_s_an @ aneq1d @ syl5bb el_s_lift @ syl bian1 heap_sat_isf) anass) @
  exan1));

theorem heap_sat_rlam: $ k |=h h /\ Dom h == a -> h = \. p e. a, read_place k @ p $ =
(named '(sylibr eqrlam @ iand (anim1 anll) @ mpd anlr @
  alimd @ com23 @ syld (bi2d @ eleq2d anr) @ syl5bi eldm @
  com23 @ syl6ibr eexb @ alimd @ a2d @ exp @ syl5ibrcom eqeq2 @ isfappd an4l anr));
theorem rlam_heap_sat: $ k e. KernelState -> k |=h \. p e. a, read_place k @ p $ =
(named '(iand (ian rlamisf) @ a1i @ ax_gen @ ax_gen @ sylbi elrlam @
  eex @ anwr @ sylbi prth @ mpbiri eqid @ eqeqd (appeq2d anl) anr));

theorem heap_sat_ss: $ q C_ p -> k |=h p -> k |=h q $ =
(named '(animd (anim1d isfss) @ alimd @ alimd @ imim1d ssel));

theorem s_weak_sat: $ P =>*s Q -> k |=s P -> k |=s Q $ =
(named '(sylbi s_weak_iff @ sylibr eexb @ alimi @ impd @ sylbi impexp @
  imim2i @ rsyl (imim1i heap_sat_isf) @ ax_2 @ eximd @ anim2d @ com12 heap_sat_ss));

theorem s_ss_sat: $ P C_ Q -> k |=s P -> k |=s Q $ = '(syl s_weak_sat ss_s_weak);

theorem s_sat_an: $ k |=s P /\s Q -> k |=s P /\ k |=s Q $ =
'(iand (s_ss_sat s_anl) (s_ss_sat s_anr));

theorem s_sat_sep: $ k |=s P *s Q -> k |=s P /\ k |=s Q $ =
'(iand (s_weak_sat s_sepl) (s_weak_sat s_sepr));

theorem s_sat_top: $ k e. KernelState <-> k |=s T.s $ =
'(ibii (syl (s_ss_sat s_emp_sstop) s_sat_emp) s_sat_ks);

theorem s_sat_lift: $ k |=s ^s p <-> k e. KernelState /\ p $ =
'(bitr3 s_sat_antop @ bitr s_sat_anlift1 @ bitr4 ancomb @ aneq1i s_sat_top);
theorem s_sat_elift: $ k e. KernelState -> (k |=s ^e p <-> p) $ =
'(syl5bb s_sat_anlift1 @ syl bian2 s_sat_emp);

theorem s_sat_weak_lift: $ P =>*s ^s p -> k |=s P -> p $ =
'(syl6 (sylbi s_sat_lift anr) s_weak_sat);
theorem s_sat_ss_lift: $ P C_ ^s p -> k |=s P -> p $ =
'(syl s_sat_weak_lift ss_s_weak);

theorem s_sat_frame_sn {q}
  (h1: $ G /\ q != p -> read_place k2 @ q = read_place k @ q $)
  (h2: $ G /\ read_place k @ p = v -> read_place k2 @ p = v2 $)
  (h3: $ G -> k |=s R *s sn (sn (p <> v)) $)
  (h4: $ G -> k2 e. KernelState $):
  $ G -> k2 |=s R *s sn (sn (p <> v2)) $ =
(named @ focus
  '(mpd h3 @ eexd @ impd @ syl5bi el_s_sep_sn2 @ eexda @ exp @ iexde _)
  (have 'H1 '(anrd anllr))
  (have 'H2 '(sylibr heap_join_S2 @ iand (rsyl H1 @
    sylbi heap_join_S2 @ anwl @ anim (anim2 @ a1i isfsn) @
    bi1i @ eqseq1 @ ineq2 @ eqstr4 dmsn dmsn) @ anwr eqcom))
  '(iand (sylibr el_s_sep_sn2 @ sylan iex (anld anllr) H2) @
    iand (iand (syl heap_join_isf3 H2) @ anw3l h4) @
    !! iald q @ !! iald a @ ! casesda _ $ q = p $ _ _ _)
  '(mpbird (anwr ,eqtac) @ anwl @
    sylbid (syl5bbr (bian2 @ mpbir (eleq2 dmsn) snid) @
      syl5bbr prelres @ eleq2d @ syl heap_join_res2 H2) @
    syl5ibrcom (sylbi elsn @ sylbi prth @ anwr ,eqtac) @
    sylan h2 an3l @ sylan heap_sat_E anlr @ sylib snss @ anrd @ syl heap_join_ss H1)
  '(sylbird (eleq2d @ syl heap_join_un @ anwl H2) @ syl5bi elun @
    syl5 orcom @ eimd (anwr @ con3 @ sylbi elsn @ sylbi prth anl) @
    syl5 orl @ syl5bir elun @ sylbid (eleq2d @ syl heap_join_un @ anwl H1) @
    sylibrd (syl (exp heap_sat_E) anllr) @ eqeq1d @ syl h1 (anim1 an3l)));

@_ local def prog_ok (elf i: nat) (P: set): wff =
$ A. k (initialConfig2 elf i k -> terminates_ensuring k P) $;

@_ local def s_ok (P T: set): wff =
$ A. k (k |=s P -> terminates_ensuring k T) $;

theorem s_ok_E: $ s_ok P T -> k |=s P -> terminates_ensuring k T $ = '(eale ,eqtac);

theorem s_ok_antop: $ s_ok (P /\s T.s) T <-> s_ok P T $ =
(named '(aleqi @ imeq1i s_sat_antop));

theorem s_ok_sep: $ s_ok (R *s P) T <-> A. r (r e. R -> s_ok (sn r *s P) T) $ =
(named @ focus
  '(bitr (aleqi _) @ bitr alcomb @ aleqi alim1)
  '(bitr (imeq1i s_sat_sep_sn) @ bitr eexb @ aleqi impexp));

theorem s_ok_weak: $ P =>*s Q -> s_ok Q T -> s_ok P T $ =
(named '(alimd @ imim1d s_weak_sat));

theorem s_ok_eexb (P: set x):
  $ s_ok (E.s x e. A, P) T <-> A. x (x e. A -> s_ok P T) $ =
(named '(bitr4 (aleqi @ bitr (imeq1i s_sat_ex) erexb) ralalcomb));

theorem s_ok_Td {k} (h: $ G /\ k |=s P -> s_ok P T $):
  $ G -> s_ok P T $ = '(ialda @ sylc s_ok_E h anr);

theorem s_ok_biim1a: $ P =>*s ^s p -> ((p -> s_ok P T) <-> s_ok P T) $ =
(named '(ibid (exp @ s_ok_Td @ mpd (imp @ anwl s_sat_weak_lift) anlr) (a1i ax_1)));

theorem s_ok_impexp: $ s_ok (^s p /\s P) T <-> (p -> s_ok P T) $ =
'(ibii (com12 @ bi1d @ syl6bb s_ok_antop @ s_okeq1d s_bian1_) @
  sylib (s_ok_biim1a s_weak_anl) @ imim2i @ s_ok_weak s_weak_anr);

--| The separation logic hoare predicate.
--| It is parameterized by a final state predicate `T` that covers the property
--| to hold on early termination, and builds in the frame rule
--| (quantifying over a heap `fr` separate from `P` and `Q`).
--| The "code" part of the hoare triple is absent because this is stored in the
--| machine state; we will use top level predicates that contain the code segment
@_ local def hoare (T P Q: set): wff =
$ A. fr (s_ok (sn fr *s Q) T -> s_ok (sn fr *s P) T) $;

theorem hoare_frame_E: $ hoare T P Q -> s_ok (R *s Q) T -> s_ok (R *s P) T $ =
(named '(sylibr (imeqi s_ok_sep s_ok_sep) @ syl ax_4 @ alimi imim2));
theorem hoare_E: $ hoare T P Q -> s_ok Q T -> s_ok P T $ =
(let ([h '(bitr (s_okeq1 s_sep_emp1a) s_ok_antop)])
  '(sylib (imeqi ,h ,h) hoare_frame_E));
theorem hoare_weak: $ P =>*s Q -> hoare T P Q $ =
(named '(iald @ syl s_ok_weak s_sep_weak2));
theorem hoare_id: $ hoare T P P $ = (named '(ax_gen id));
theorem hoare_tr: $ hoare T P Q -> hoare T Q R -> hoare T P R $ =
(named '(syl ax_4 @ alimi imim2));

-- The famous "frame rule" of separation logic.
theorem hoare_frame: $ hoare T P Q -> hoare T (R *s P) (R *s Q) $ =
(named '(iald @ sylib (imeqi (s_okeq1 s_sepass) (s_okeq1 s_sepass)) hoare_frame_E));
theorem hoare_frame_r: $ hoare T P Q -> hoare T (P *s R) (Q *s R) $ =
'(sylib (hoareeq eqsid s_sepcom s_sepcom) hoare_frame);

theorem hoare_save_restore_lem (G: wff p)
  (hA: $ G -> finite A $)
  (hp: $ G -> p e. P $)
  (h1: $ G -> Dom p i^i A == 0 $)
  (h2: $ G -> heap_join fr p = suc fp $)
  (h3: $ G -> k |=h fp $):
  $ G -> E. a E. a1 E. af E. f1 E. afp (Dom a == A /\
      heap_join a1 af = suc a /\
      heap_join fp a1 = suc afp /\
      heap_join f1 af = suc fr /\
      k |=h afp) $ =
(focus
  (foldr '($A$  $ A i^i Compl (Dom fr) $  $ A i^i Dom fr $
    $ Dom fr i^i Compl A $  $ Dom fp u. A $) _
    (fn (x y) '(! iexde _ _ $ \. x e. lower ,x, _ $ _ ,y)))
  '(mpbird ,eqtac @ anw5l @ iand (iand (iand (iand _ _) _) _) _)
  (def A '(mpbi eqlower @ infin1 _))
  (have 'ha '(sylib eqlower hA))
  (have 'hb '(sylib eqlower @ syl infin1 hA))
  (have 'hc '(sylib eqlower @ syl infin1 hA))
  (have 'hd '(a1i @ mpbi eqlower @ infin1 @ dmfin finns))
  (have 'hp '(a1i @ mpbi eqlower @ dmfin finns))
  (have 'hfr '(a1i @ mpbi eqlower @ dmfin finns))
  (have 'hy '(sylib eqlower @ syl (unfin @ dmfin finns) hA))
  (def (f x y) '(sylan heap_sat_rlam ,x ,y))
  (focus '(syl5eqs dmrlam @ eqscomd ha))
  (focus
    '(mpbiri (iani _ _) @ sylan heap_join_rlam2 (iand hb hc) ha)
    '(eqstr3 inindi @ sseq0 inss2 incpl1)
    '(eqstr3 indi @ mpbi eqin1 @ mpbir (sseq2 uncpl1) ssv2))
  (focus
    '(eqtrd (heap_joineq1d ,(f 'h3 'hp)) @
      mpbird (sylan heap_join_rlam2 (iand hp hb) hy) @
      iand (eqstr3d (ineq1d @ syl heap_join_dmun h2) @
        syl5eqs indir @ sylibr uneq0 @ iand (a1i @ mpbir ineq0r inss2) @
        syl (sseq0 @ ssin2 inss1) h1) @
      !! iald x @ bitr4g elun elun @ syl oreq2a @ syl6 (syl5bb elin bian2) @
        syl6ibr elcpl @ con3d @ syl ssel @ syl dmss @ anld @ syl heap_join_ss h2))
  (focus
    '(eqtr4d (mpbiri (iani _ _) @ sylan heap_join_rlam2 (iand hd @ syl5eqs incom hc) hfr) @
      suceqd ,(f '(mpd h3 @ rsyl h2 @ syl heap_sat_ss @ anld heap_join_ss) 'hfr))
    '(eqstr3 inindi @ sseq0 inss2 incpl1)
    '(eqstr3 indi @ mpbi eqin1 @ mpbir (sseq2 uncpl1) ssv2))
  (focus '(syl rlam_heap_sat @ syl heap_sat_ks h3)));

--| A partial inverse to the frame rule: we can "unframe" by some heap `a`
--| with specified domain `A`. This allows us to prove that as long as we return
--| the values to what they were, we are permitted to capture things not in
--| the heap of `P`. This is useful for e.g. proving that callee-saved registers
--| can be used in a function and restored at the end, without the caller having
--| to pass them in.
theorem hoare_save_restore (G: wff p a)
  (hA: $ G -> finite A $)
  (h1: $ G -> A. p (p e. P -> Dom p i^i A == 0) $)
  (h2: $ G -> A. a (Dom a == A -> hoare T (sn a *s P) (sn a *s Q)) $):
  $ G -> hoare T P Q $ =
(named @ focus
  '(!! iald fr @ exp @ iald @ eexd @
    impd @ syl5bi el_s_sep_sn1 @ eexda @ exp @
    mpd (hoare_save_restore_lem (anw3l hA) (anld anlr) _ (anrd anlr) anr) _)
  (focus '(sylc _ (anw3l h1) (anld anlr)) '(eale ,eqtac))
  '(eexd @ eexd @ eexd @ eexd @ eexda @ sylc eal {_ : $ _ -> s_ok _ _ $} _)
  (focus
    '(sylc hoare_frame_E _ @ sylc s_ok_weak _ an3lr)
    (focus '(sylc _ (anw4l h2) @ anwr an4l) '(eale ,eqtac))
    '(sylib (s_weakeq1 s_sepass) @ syl s_sep_weak1 @
      mpbii (s_sep_weak1 s_sepl) @ anwr @ s_weakeqd (syl5eqs s_sepass @
        s_sepeq2d @ sylibr s_sep_sn an3lr) @ sylibr s_sep_sn anlr))
  (focus
    '(sylan iex (mpbird (eleq2d _) @ sylibr el_s_sep_sn1 _) anrr)
    '(anwr @ eqstr3g s_sepass s_sepass @ s_sepeq1d @
      eqstr3d (s_sepeq2d @ syl5eqs s_sepcom @ sylibr s_sep_sn an3lr) @
      syl5eqsr s_sepass @ syl6eqs s_sepcom @ s_sepeq1d @ sylibr s_sep_sn anlr)
    '(sylan iex (sylibr el_s_sep_sn1 _) (anwr @ syl5eq heap_join_com anllr))
    '(sylan iex (anld anllr) (anrd anllr))));

theorem hoare_ksStep {k fr}
  (h1: $ G /\ k |=s sn fr *s P ->
         (P. k2 ksStep k k2 -> k2 |=s sn fr *s Q) $)
  : $ G -> hoare T P Q $ =
'(ialda @ ialda @
  sylibr (!! terminates_ensuring_val k3) @ iand (syl s_sat_ks anr) @
  iald @ syl5bi ksReachable_hd @ sylbi anrass @
  eord (syl5ibrcom (anwr @ rsyl eqcom ,eqtac) @
    imp @ mpd (syl pimex12 h1) @ eexd @ impd @ exp @ expd @ syl5 (impcom s_ok_E) @
    syl5 terminates_ensuring_can @ syl can_terminate_ensuring_R @
    anwr ksReachable1) @
  imp @ com23 @ eexda @ syl5 s_ok_E @ eimd (imp @ syl5 anl @ syl eal @ anrd h1) @
  syl6 terminates_ensuring_can @ syl terminates_ensuring_R anrr);

theorem hoare_step {k fr}
  (h1: $ G /\ k |=s sn fr *s P ->
         (P. k2 step (ksCfg k) k2 -> setCfg k k2 |=s sn fr *s Q) $)
  : $ G -> hoare T P Q $ =
(focus
  (have 'h3 '(syl s_sat_ks anlr))
  '(hoare_ksStep @ iand _ @ iald @ syl5 anr @ eord _ _)
  (focus '(mpd (anld h1) @ eexda @ syl (iexe ,eqtac) @ iand h3 @ orld @
    syl (iexe ,eqtac) @ iand anr @
    iand (sylibr anass @ sylib (aneq2a setCfgT) @ iand h3 @
      syl s_sat_ks @ imp @ syl eal @ anrd h1) eqidd))
  (focus '(eexd @ impd @ exp @ syl5ibrcom (anwr s_sateq1) @ imp @ syl eal @ anrd h1))
  (focus '(syl absurd @ rsyl (anld h1) @ eex step_no_IO)));

theorem hoareeq3g (h1: $ P == P2 $) (h2: $ Q == Q2 $)
  (h: $ G -> hoare T P Q $): $ G -> hoare T P2 Q2 $ =
'(sylib (hoareeq eqsid h1 h2) h);

theorem hoareeq4g (h1: $ P == P2 $) (h2: $ Q == Q2 $)
  (h: $ G -> hoare T P2 Q2 $): $ G -> hoare T P Q $ =
'(sylibr (hoareeq eqsid h1 h2) h);

theorem hoare_exim (P Q: set x):
  $ A. x (x e. A -> hoare T P Q) ->
    hoare T (E.s x e. A, P) (E.s x e. A, Q) $ =
(named (def h '(bitr3 s_ok_eexb @ s_okeq1 s_exsep1))
  '(iald @ sylib (imeqi ,h ,h) @ al2imi @ a2d @ imim2i hoare_frame_E));

theorem hoare_eexb (P: set x):
  $ A. x (x e. A -> hoare T P Q) <-> hoare T (E.s x e. A, P) Q $ =
(named (def h '(bitr3 s_ok_eexb @ s_okeq1 s_exsep1))
 '(bitr ralcomb @ aleqi @ imeq2i ,h));

theorem hoare_iex (Q: set x):
  $ E. x (x e. A /\ hoare T P Q) -> hoare T P (E.s x e. A, Q) $ =
(named (def h '(bitr3 s_ok_eexb @ s_okeq1 s_exsep1))
 '(rsyl rexal @ alimi @ syl5bir ,h @ com12 @ sylibr erexb @ alimi @ imim2i mpcom));

theorem hoare_iexe (Q: set x) (e: $ G /\ x = a -> Q == Q2 $)
  (h1: $ G -> a e. A $)
  (h2: $ G -> hoare T P Q2 $): $ G -> hoare T P (E.s x e. A, Q) $ =
'(syl hoare_iex @ iexde @ iand (mpbird (eleq1d anr) (anwl h1)) @
  mpbird (hoareeq3d e) (anwl h2));

theorem hoare_Td {k} (h: $ G /\ k |=s P -> hoare T P Q $):
  $ G -> hoare T P Q $ =
(named '(ialda @ ialda @ mpd anr @ syl eal @ mpd anlr @ syl eal @
  sylan h anll @ anwr @ s_weak_sat s_sepr));

theorem hoare_weakl: $ P =>*s Q -> hoare T Q R -> hoare T P R $ =
'(rsyl hoare_weak hoare_tr);

theorem hoare_weakr: $ Q =>*s R -> hoare T P Q -> hoare T P R $ =
'(rsyl hoare_weak @ com12 hoare_tr);

theorem hoare_biim1a:
  $ P =>*s ^s p -> ((p -> hoare T P Q) <-> hoare T P Q) $ =
(named '(syl5bbr ralim1 @ aleqd @ imeq2d @ syl5bbr alim1 @
  aleqd @ syl5bbr impexp @ imeq1d @ syl bian1a @
  syl6 (sylbi s_sat_lift anr) (syl s_weak_sat s_sepwr)));

theorem hoare_impexp:
  $ hoare T (^s p /\s P) Q <-> (p -> hoare T P Q) $ =
(named '(bitr (raleqi @ bitr (aleqi @
  bitr (imeq1i @ bitr (s_sateq2 s_sep_anlift2) s_sat_anlift1) impexp) alim1) ralim1));

theorem hoare_animd (h1: $ G /\ p -> q $) (h2: $ G /\ p -> hoare T P Q $):
  $ G -> hoare T (^s p /\s P) (^s q /\s Q) $ =
'(sylibr hoare_impexp @ exp @
  sylc hoare_weakr (sylib s_weak_antop1 @
    syl ss_s_weak @ sylibr (sseq1 s_ancom) @
    syl s_anim1 @ sylibr s_lift_ss @ a1d h1) h2);

@_ local def hoareCfg (k: nat) (R P Q: set): wff =
$ A. ks (ksCfg ks = k -> A. fr (ks |=s sn fr *s P ->
    (P. k2 k2 e. R -> setCfg ks k2 |=s sn fr *s Q))) $;

theorem hoareCfgeq3g (h1: $ P == P2 $) (h2: $ Q == Q2 $)
  (h: $ G -> hoareCfg k R P Q $): $ G -> hoareCfg k R P2 Q2 $ =
'(sylib (hoareCfgeq eqid eqsid h1 h2) h);

theorem hoareCfgeq4g (h1: $ P == P2 $) (h2: $ Q == Q2 $)
  (h: $ G -> hoareCfg k R P2 Q2 $): $ G -> hoareCfg k R P Q $ =
'(sylibr (hoareCfgeq eqid eqsid h1 h2) h);

theorem hoareCfg_ab (p: wff k2):
  $ hoareCfg k {k2 | p} P Q <->
    A. ks (ksCfg ks = k -> A. fr (ks |=s sn fr *s P ->
      (P. k2 p -> setCfg ks k2 |=s sn fr *s Q))) $ =
(named '(aleqi @ imeq2i @ aleqi @ imeq2i @
  cbvpimh (nfel2 nfab1) nfv nfv nfv (syl6bb abid eleq1) @ s_sateq1d setCfgeq2));

theorem hoareCfgeq2da {ks} (p q: wff k2)
  (h: $ G /\ ksCfg ks = k /\ ks |=s P -> (p <-> q) $):
  $ G -> (hoareCfg k {k2 | p} P Q <-> hoareCfg k {k2 | q} P Q) $ =
(named '(aleqd @ imeq2da @ aleqd @ imeq2da @ pimeq1d @ eleq2d @ abeqd @
  syl h @ anim2 @ s_weak_sat s_sepr));

theorem hoareCfg_frame_E: $ hoareCfg (ksCfg ks) R P Q ->
  ks |=s F *s P -> (P. k2 k2 e. R -> setCfg ks k2 |=s F *s Q) $ =
(named '(ealie @ eimd ksCfgeq @ sylbid ,eqtac @ a1i @
  syl5bi s_sat_sep_sn @ syl6ibr (pimeq2i s_sat_sep_sn) @
  syl6 rexpim @ syl exim @ alimi anim2));

theorem hoareCfg_sn_frame_E: $ hoareCfg (ksCfg ks) (sn k2) P Q ->
  ks |=s R *s P -> setCfg ks k2 |=s R *s Q $ =
(named '(syl6ib (bitr (pimeq1i elsn) (pimeqe @ s_sateq1d setCfgeq2)) hoareCfg_frame_E));

theorem hoareCfg_frame_E_ab (p: wff k2): $ hoareCfg (ksCfg ks) {k2 | p} P Q ->
  ks |=s F *s P -> (P. k2 p -> setCfg ks k2 |=s F *s Q) $ =
(named '(syl6ib (cbvpimh (nfel2 nfab1) nfv nfv nfv (syl6bb abid eleq1) @
  s_sateq1d setCfgeq2) hoareCfg_frame_E));

theorem hoareCfg_E_ex (p: wff k2)
  (h: $ G -> hoareCfg k {k2 | p} P Q $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> E. k2 p $ =
'(syl pimex @ sylc hoareCfg_frame_E_ab (mpbird (hoareCfgeq1d anlr) (anwll h)) @
  sylibr s_sat_sep_emp1 anr);

theorem hoareCfg_frame: $ hoareCfg k R P Q -> hoareCfg k R (F *s P) (F *s Q) $ =
(named '(imidm @ alimd @ a2d @ com12 @ sylbird ,(eqtac-with #f) @
  a1i @ a1d @ iald @ sylib (imeqi (s_sateq2 s_sepass) @ pimeq2i (s_sateq2 s_sepass)) @
  hoareCfg_frame_E));

theorem hoareCfg_frame_r: $ hoareCfg k R P Q -> hoareCfg k R (P *s F) (Q *s F) $ =
'(sylib (hoareCfgeq eqid eqsid s_sepcom s_sepcom) hoareCfg_frame);

theorem hoareCfg_exim (P Q: set x):
  $ A. x (x e. A -> hoareCfg k R P Q) ->
    hoareCfg k R (E.s x e. A, P) (E.s x e. A, Q) $ =
(named (def h '(bitr3 s_sat_ex @ s_sateq2 s_exsep1))
 '(sylbi ralcomb @ alimi @ imim2i @ sylbi ralalcomb @ alimi @
    sylib (imeqi ,h @ pimeq2i ,h) @ syl6 rexpim @ syl exim @ alimi anim2a));

theorem hoareCfg_eexb (P: set x):
  $ A. x (x e. A -> hoareCfg k R P Q) <-> hoareCfg k R (E.s x e. A, P) Q $ =
(named (def h '(bitr3 s_sat_ex @ s_sateq2 s_exsep1))
 '(bitr ralcomb @ aleqi @ imeq2i @ bitr ralalcomb @ aleqi @
    bitr3 erexb (imeq1i ,h)));

theorem hoareCfg_iex (Q: set x):
  $ E. x (x e. A /\ hoareCfg k R P Q) -> hoareCfg k R P (E.s x e. A, Q) $ =
(named (def h '(bitr3 s_sat_ex @ s_sateq2 s_exsep1))
 '(rsyl rexral @ alimi @ imim2i @ rsyl rexral @ alimi @ imim2i @
   sylib (pimeq2i ,h) rexpim1));

theorem hoareCfg_iexe (Q: set x) (e: $ G /\ x = a -> Q == Q2 $)
  (h1: $ G -> a e. A $)
  (h2: $ G -> hoareCfg k R P Q2 $): $ G -> hoareCfg k R P (E.s x e. A, Q) $ =
'(syl hoareCfg_iex @ iexde @ iand (mpbird (eleq1d anr) (anwl h1)) @
  mpbird (hoareCfgeq4d e) (anwl h2));

theorem hoareCfg_Td {ks} (h: $ G /\ ksCfg ks = k /\ ks |=s P -> hoareCfg k R P Q $):
  $ G -> hoareCfg k R P Q $ =
(named '(ialda @ ialda @ sylc hoareCfg_frame_E
  (mpbird (hoareCfgeq1d anlr) @ syl h @ anim2 @ s_weak_sat s_sepr) anr));

theorem hoareCfg_T1: $ (k e. Config -> hoareCfg k R P Q) <-> hoareCfg k R P Q $ =
(named '(ibii (hoareCfg_Td @ mpd (mpbid (eleq1d anlr) @ anwr @ syl ksCfgT s_sat_ks) anll) ax_1));

theorem hoareCfg_weakl: $ P =>*s Q -> hoareCfg k K Q R -> hoareCfg k K P R $ =
(named '(alimd @ imim2d @ alimd @ imim1d @ syl s_weak_sat s_sep_weak2));

theorem hoareCfg_weakr: $ Q =>*s R -> hoareCfg k K P Q -> hoareCfg k K P R $ =
(named '(alimd @ imim2d @ alimd @ imim2d @ pimim2d @ syl s_weak_sat s_sep_weak2));

theorem hoareCfg_id: $ hoareCfg k (sn k) P P $ =
(named '(ax_gen @ iald @ bi1d @ syl6bbr (bitr (pimeq1i elsn) (pimeqe ,eqtac)) @
  s_sateq1d @ syl5eqr set_ksCfg setCfgeq2));

theorem hoareCfg_id2: $ R == sn k -> P =>*s Q -> hoareCfg k R P Q $ =
'(exp @ mpbird (hoareCfgeq2d anl) @ anwr @ mpi hoareCfg_id hoareCfg_weakl);

theorem hoareCfg_biim1a:
  $ P =>*s ^s p -> ((p -> hoareCfg k R P Q) <-> hoareCfg k R P Q) $ =
(named '(syl5bbr ralim1 @ aleqd @ imeq2d @ syl5bbr alim1 @
  aleqd @ syl5bbr impexp @ imeq1d @ syl bian1a @
  syl6 (sylbi s_sat_lift anr) (syl s_weak_sat s_sepwr)));

theorem hoareCfg_impexp:
  $ hoareCfg k R (^s p /\s P) Q <-> (p -> hoareCfg k R P Q) $ =
(named '(bitr (raleqi @ bitr (aleqi @
  bitr (imeq1i @ bitr (s_sateq2 s_sep_anlift2) s_sat_anlift1) impexp) alim1) ralim1));

theorem hoareCfg_iand (h1: $ G -> q $) (h2: $ G -> hoareCfg k R P Q $):
  $ G -> hoareCfg k R P (^s q /\s Q) $ =
'(sylc hoareCfg_weakr (sylib s_weak_antop1 @
    syl ss_s_weak @ sylibr (sseq1 s_ancom) @
    syl s_anim1 @ sylibr s_lift_ss @ a1d h1) h2);

theorem hoareCfg_animd (h1: $ G /\ p -> q $) (h2: $ G /\ p -> hoareCfg k R P Q $):
  $ G -> hoareCfg k R (^s p /\s P) (^s q /\s Q) $ =
'(sylibr hoareCfg_impexp @ exp @ hoareCfg_iand h1 h2);

theorem hoareCfg_pim (p: wff k2) (q: wff k2 k3) (r: wff k3)
  (h1: $ G -> hoareCfg (ksCfg k) {k2 | p} P Q $)
  (h2: $ G /\ p /\ setCfg k k2 |=s F *s Q -> (P. k3 q -> r) $):
  $ G /\ k |=s F *s P -> (P. k3 E. k2 (p /\ q) -> r) $ =
'(sylc pimtr (sylibr (pimeq2a @ ax_gen bian1) @ imp @ syl hoareCfg_frame_E_ab h1) @
  iald @ anwl @ exp @ sylbir anass h2);

theorem hoareCfg_tr (p: wff k2) (q: wff k2 k3)
  (h1: $ G -> hoareCfg k {k2 | p} P Q $)
  (h2: $ G /\ p -> hoareCfg k2 {k3 | q} Q R $):
  $ G -> hoareCfg k {k3 | E. k2 (p /\ q)} P R $ =
(named '(sylibr hoareCfg_ab @ ialda @ ialda @
  hoareCfg_pim (mpbird (hoareCfgeq1d anr) @ anwl h1) @
  sylib (pimeq2i @ s_sateq1 set_setCfg) @ imp @ syl hoareCfg_frame_E_ab @
  sylibr (hoareCfgeq1 ksCfg_setCfg) @ rsyl (anim1 anl) h2));

theorem hoareCfg_tr1
  (h1: $ G -> hoareCfg k (sn k2) P Q $)
  (h2: $ G -> hoareCfg k2 T Q R $):
  $ G -> hoareCfg k T P R $ =
(named '(sylib (hoareCfgeq2 @ eqab1i @ exeqe ,eqtac) @
  hoareCfg_tr (sylib (hoareCfgeq2 @ eqab2i elsn) h1) @
  mpbird (hoareCfgeqd anr (a1i abid2) eqsidd eqsidd) @ anwl h2));

theorem hoareCfg_step {k} (h: $ G -> hoareCfg k {k2 | step k k2} P Q $):
  $ G -> hoare T P Q $ =
(named '(hoare_step @ imp @ syl hoareCfg_frame_E_ab @
  rsyl (!! iald k h) (eale ,eqtac)));

theorem hoareCfg_sn_d {q ks fr} (k2: nat ks)
  (e: $ k = ksCfg ks -> k3 = k2 $)
  (ha: $ G /\ k = ksCfg ks -> P =>*s sn (sn (p <> v)) $)
  (h1: $ G /\ k = ksCfg ks /\ ks |=s P -> k2 e. Config $)
  (h2: $ G /\ k = ksCfg ks /\ ks |=s P ->
    PageMapping (getMemory (ksCfg ks)) C_ PageMapping (getMemory k2) $)
  (h3: $ G /\ k = ksCfg ks /\ ks |=s P /\ q != p ->
    read_place (setCfg ks k2) @ q = read_place ks @ q $)
  (h4: $ G /\ k = ksCfg ks /\ ks |=s P /\
    read_place ks @ p = v -> read_place (setCfg ks k2) @ p = v2 $)
  (h5: $ G /\ k = ksCfg ks /\ ks |=s P ->
    setCfg ks k2 |=s sn fr *s sn (sn (p <> v2)) -> setCfg ks k2 |=s sn fr *s Q $):
  $ G -> hoareCfg k (sn k3) P Q $ =
(focus
  (have 'H1 '(anim2 @ s_weak_sat s_sepr))
  '(iald @ syl5 eqcom @ exp @ ialda @
    mpbird (pimeq1d @ syl5bb elsn @ eqeq2d @ syl e anlr) @
    sylibr (pimeqe ,eqtac) @ mpd _ @ syl h5 H1)
  '(s_sat_frame_sn (syl h3 @ anim1 H1) (syl h4 @ anim1 H1)
      (sylc s_weak_sat (syl s_sep_weak2 @ anwl ha) anr) @
    rsyl (anim2 @ s_weak_sat s_sepr) (mpbird (syl setCfgT @ anwr s_sat_ks) @
    iand h1 @ sseld h2 @ syl ksMappingT @ anwr s_sat_ks)));

theorem hoareCfg_sn {q ks} (k2: nat ks)
  (e: $ k = ksCfg ks -> k3 = k2 $)
  (h1: $ G /\ ks e. KernelState -> k2 e. Config $)
  (h2: $ G /\ ks e. KernelState -> PageMapping (getMemory (ksCfg ks)) C_ PageMapping (getMemory k2) $)
  (h3: $ G /\ q != p -> read_place (setCfg ks k2) @ q = read_place ks @ q $)
  (h4: $ G /\ read_place ks @ p = v -> read_place (setCfg ks k2) @ p = v2 $):
  $ G -> hoareCfg k (sn k3) (sn (sn (p <> v))) (sn (sn (p <> v2))) $ =
(named '(hoareCfg_sn_d e (a1i s_weak_id)
    (syl h1 @ anim anl s_sat_ks) (syl h2 @ anim anl s_sat_ks)
    (syl h3 @ anim1 anll) (syl h4 @ anim1 anll) idd));

--| The primitive memory heaplet: `s_mem1 p a v` says that
--| address `a` is mapped with permission `p`,
--| and if the data at `a` is readable then the value is `v`.
@_ local def s_mem1 (p a v): set =
$ ^s (a e. u64 /\ v e. u8 /\ p e. Prot) /\s
    sn (sn (X86P_Mem a <> ((p <> v) <> suc p))) $;

theorem el_s_mem1: $ h e. s_mem1 p a v <->
  a e. u64 /\ v e. u8 /\ p e. Prot /\
  h = sn (X86P_Mem a <> ((p <> v) <> suc p)) $ =
'(bitr el_s_an @ bitr (aneq el_s_lift elsn) @
  aneq1a @ syl bian1 @ mpbiri isfsn @ isfeqd nseq);

theorem s_mem1_subsn: $ subsn (s_mem1 p a v) $ = '(subsnss s_anr subsnsn);
theorem s_mem1_sstop: $ s_mem1 p a v C_ T.s $ = '(sstr s_anl s_lift_sstop);

theorem s_mem1_getMemory:
  $ k |=s s_mem1 p a v ->
    getMemory (ksCfg k) @ a = p <> v /\
    ksMapping k @ a = suc p $ =
(named '(eex @ imp @ sylbi el_s_mem1 @ anwr @
  sylbid heap_sateq2 @ a1i @ sylbi heap_sat_sn @
  sylib prth @ sylib (eqeq1 read_place_Mem) anr));

theorem s_mem1_readMemory1:
  $ k |=s s_mem1 p a v /\ ps C_ p ->
    readMemory1 ps (getMemory (ksCfg k)) a v $ =
'(iand (iand (syl getMemoryT @ syl ksCfgT @ anwl s_sat_ks) @
    anwl @ sylbi s_sat_anlift1 an3l) @
  syl (iexe ,eqtac) @ anim1 @ anld s_mem1_getMemory);

theorem s_mem1_hoareCfg
  (h1: $ G -> v e. u8 $)
  (h2: $ G -> setMem1 (getMemory k) a v = m2 <> 0 $):
  $ G -> hoareCfg k (sn (setMemory k m2)) (s_mem1 p a w)
    (^s (PROT_READ + PROT_WRITE C_ p) /\s s_mem1 p a v) $ =
(named @ focus
  (def G $ G /\ k = ksCfg ks /\ ks |=s s_mem1 p a w $)
  (have 'H1 $ ,G -> a e. u64 /\ w e. u8 /\ p e. Prot $
    '(anld @ sylib s_sat_anlift1 anr))
  (have 'H1a $ ,G -> a e. u64 $ '(rsyl H1 anll))
  (have 'H2 $ ,G -> PROT_READ + PROT_WRITE C_ fst (getMemory k @ a) $
    '(anwll @ mpi peano1 @ con1d @ exp @ anrd @
      sylib prth @ eqtr3d (anwr ifneg) (anwl h2)))
  (have 'H3 $ ,G -> PROT_READ + PROT_WRITE C_ p $
    '(mpbid (sseq2d @ nseqd @ syl6eq fstpr @ fsteqd @
        eqtrd (appneq1d @ getMemoryeqd anlr) @ anwr @ anld s_mem1_getMemory) H2))
  (have 'H4 $ ,G -> ksCfg ks e. Config $ '(syl ksCfgT @ anwr s_sat_ks))
  (have 'H5 $ ,G -> k e. Config $ '(mpbird (eleq1d anlr) H4))
  (have 'H6 $ ,G ->
      fst (setMem1 (getMemory (ksCfg ks)) a v) ==
      write (getMemory (ksCfg ks)) a (fst (getMemory (ksCfg ks) @ a) <> v) $
    '(syl6eqsr (mpbi eqlower @ writefin finns) @
      nseqd @ syl6eq fstpr @ fsteqd @ syl ifpos @
      mpbid (sseq2d @ nseqd @ fsteqd @ appneq1d @ getMemoryeqd anlr) H2))
  '(mpbid (hoareCfgeq2d @ nseqd @ sneqd @ setMemoryeq2d @ syl6eq fstpr @ fsteqd h2) @
    hoareCfg_sn_d ,eqtac _ _ _ _ _ _)
  (focus '(a1i @ ss_s_weak s_anr))
  (focus '(sylan setMemoryT H4 @ syl xpfst @ sylan setMem1_T
    (iand (syl getMemoryT H4) H1a) @ anwll h1))
  (focus
    '(sylibr _ @ sylan setMem1PM (iand (syl getMemoryT H4) H1a) @ anwll h1)
    '(sseq2 @ PageMappingeq get_setMemory))
  (focus
    '(imp @ casesd (eexd _) @ a1i @ a1d read_place_setMemory_ne)
    '(syl5ibrcom {,eqtac : $ q = _ -> _ $} @ syl5bi (noteq @ bitr b1can b1can) @
      exp @ eqtr4g read_place_setMemory_eq read_place_Mem @ preq1d @
      eqtrd (appeq1d @ anwl H6) @ anwr writeNe))
  (focus
    '(syl5eq read_place_setMemory_eq @
      sylan (preqd _ anlr) (sylib prth @ syl5eqr read_place_Mem anr) @ anwl H6)
    '(eqtrd (appeq1d anr) @ syl5eq writeEq @ preq1d @ syl6eq fstpr @ fsteqd anll))
  (focus
    '(bi2d @ s_sateq2d @ s_sepeq2d @ eqstrd (syl (s_bian1 s_mem1_sstop) H3) @
      sylan (s_bian1 @ mpbir s_sn_sstop isfsn) (iand H1a @ anwll h1) (anrd H1))));

--| The primitive memory heaplet: `s_pto a v` or `a >->m v` says that
--| address `a` is mapped, and if the data at `a` is readable then the value is `v`.
--| It does not imply readability of the memory since if the data is not readable
--| we can conclude anything (because reading will cause a crash).
@_ local def s_pto (a v): set =
$ E.s p e. Prot, (^s (PROT_READ C_ p) /\s s_mem1 p a v) $;
infixl s_pto: $>->m$ prec 80;

theorem el_s_pto: $ h e. a >->m v <-> a e. u64 /\ v e. u8 /\
  E. p (p e. Prot /\ PROT_READ C_ p /\
    h = sn (X86P_Mem a <> ((p <> v) <> suc p))) $ =
'(bitr4 el_s_ex @ bitr3 exan1 @ exeqi @ bitr anlass @ bitr4 anass @
  aneq2a @ syl5bb el_s_an @ syl5bb (aneq1a @
    syl5bb el_s_lift @ syl bian1 @ el_sstop s_mem1_sstop) @
  aneq2d @ syl5bb el_s_mem1 @ aneq1d bian2);

theorem s_pto_sstop: $ a >->m v C_ T.s $ = (named '(s_eex @ sstr s_anl s_lift_sstop));

theorem s_pto_readMemory1:
  $ k |=s a >->m v ->
    readMemory1 PROT_READ (getMemory (ksCfg k)) a v $ =
(named '(sylbi s_sat_ex @ eex @ anwr @ sylbi s_sat_anlift1 @
  syl s_mem1_readMemory1 ancom));

--| The primitive memory heaplet: `s_mem P a v` says that the
--| list of bytes `v` is at address `a`, where every byte has permission from the set `P`
--| (different bytes may have different permissions).
@_ local def s_mem (P a v): set =
$ ^s (a + len v e. u64 /\ v e. List u8) /\s
  |*|s i e. upto (len v), E.s p e. P @' (a + i), s_mem1 p (a + i) (nth i v - 1) $;

theorem s_mem_sstop: $ s_mem P a v C_ T.s $ = (named '(sstr s_anl s_lift_sstop));
theorem s_mem_T: $ s_mem P a v C_ ^s (a + len v e. u64 /\ v e. List u8) $ = (named 's_anl);
theorem s_mem_T2: $ k |=s s_mem P a v -> a + len v e. u64 /\ v e. List u8 $ = '(s_sat_ss_lift s_mem_T);

theorem s_mem_ss: $ A. i (i < len v -> P @' (a + i) C_ Q @' (a + i)) -> s_mem P a v C_ s_mem Q a v $ =
(named '(syl s_anim2 @ syl s_Sep_ss @ iald @ syl5bi elupto @
  rsyl (eale ,eqtac) @ imim2i s_exim1));

theorem s_mem_0: $ s_mem P a 0 == ^e (a e. u64) $ =
(named '(s_aneq (s_lifteq @ bitr (bian2 elList0) @ eleq1 @ eqtr (addeq2 len0) add02) @
  eqstr (s_Sepeq1 @ nseq @ eqtr (uptoeq len0) upto0) s_Sep_0));

theorem s_mem_S: $ s_mem P a (b : v) == E.s p e. P @' a, s_mem1 p a b *s s_mem P (suc a) v $ =
(named '(eqstr4
  (s_aneq
    (s_lifteq @ bitr (aneq (eleq1 @ eqtr4 (addeq2 lenS) addSass) elListS) anlass) @
    eqstr (s_Sepeq1 @ nseq @ uptoeq lenS) @
    trud @ s_Sep_uptoS
      (anwr @ s_exeqd (rappeq2d @ syl6eq add02 addeq2) @
        s_mem1eqd eqidd (syl6eq add02 addeq2) @
        syl6eq sucsub1 @ subeq1d @ syl6eq nthZ @ ntheq1)
      (anwr @ s_exeqd (rappeq2d @ syl6eqr addSass addeq2) @
        s_mem1eqd eqidd (syl6eqr addSass addeq2) @
        subeq1d @ syl6eq nthS ntheq1) @
    a1i @ s_eex s_mem1_sstop) @
  eqstr3 (s_sepeq1 @ mpbi s_bian1a @ s_eex @ s_anwl @ mpbir s_lift_ss anlr) @
  s_sep_anlift));

theorem s_mem_A: $ len v = n -> s_mem P a (v ++ w) == s_mem P a v *s s_mem P (a + n) w $ =
(named @ focus
  (have 'H '(eqtrd (addeq2d anr) @ syl5eqr addass @ addeq1d @ addeq2d anl))
  '(syl6eqsr s_sep_anlift @
    eqstrd (s_aneq2d @
      syl5eqs (s_Sepeq1 @ nseq @ uptoeq appendlen) @
      s_Sep_uptoA @ s_exeqd (rappeq2d H) @ s_mem1eqd eqidd H @
      subeq1d @ syl6eq appendnth2_ (ntheq1d anr)) @
    s_aneqd (s_lifteqd @ syl6bb an4 @ aneqd
      (syl5bb (eleq1 @ eqtr4 (addeq2 appendlen) addass) @
        syl5bbr (bian1a @ u64le1 leaddid1) @ aneq2d @ eleq1d @ addeq1d addeq2)
      (a1i appendT)) @
    s_sepeq1d @ s_Sepeq2da @ s_exeq2d @ s_mem1eq3d @
    subeq1d @ syl appendnth1 @ sylib elupto anr));

theorem s_mem_readMemory {y} (G: wff x)
  (h1: $ G -> ps e. Prot $)
  (h2: $ G -> k |=s s_mem P a v $)
  (hp: $ G -> A. x (y <> x e. P -> ps C_ x) $):
  $ G -> readMemory ps (getMemory (ksCfg k)) a v $ =
(named @ focus
  '(mpd h2 @ syl (!! eale b ,(eqtac-gen 'a)) ,(induct '(listindd) 'v _ _))
  '(iald @ syl5bi (s_sateq2 s_mem_0) @ syl5bi s_sat_anlift1 @
    exp @ sylibr readMemory0 @
    iand (iand (anwl h1) @ syl getMemoryT @ syl ksCfgT @ rsyl anrr s_sat_ks) anrl)
  '(sylibr (cbval ,eqtac) @ iald @ syl5bi (s_sateq2 s_mem_S) @
    syl5 s_sat_sep @ syl6ibr readMemoryS @ animd _ _)
  (focus
    '(syl5bi s_sat_ex @ rsyl (anwl hp) @
      sylibr erexb @ alimi @ syl5bi elrapp @ imim2i @ com12 @ exp s_mem1_readMemory1))
  '(imp @ syl5 (eale ,eqtac) @ a2d @ exp @ bi2d @ readMemoryeq3d @
    syl add64S_eqid @ syl (u64le1 leaddid1) @ anld @ anwr s_mem_T2));

theorem s_mem_hoareCfg {p x}
  (h1: $ G -> v e. List u8 $)
  (h2: $ G -> len w = len v $)
  (h3: $ G /\ PROT_READ + PROT_WRITE C_ p -> x <> p e. P -> x <> p e. Q $)
  (h4: $ G -> setMem (getMemory k) a v = m2 <> 0 $):
  $ G -> hoareCfg k (sn (setMemory k m2)) (s_mem P a w) (s_mem Q a v) $ =
(named @ focus
  (def (f x y) '(syl (eale ,(eqtac-gen x)) ,y))
  '(mpd (iand (iand h1 h2) h4) ,(f 'a @ f 'w @ f 'm2 @ f 'k @ induct '(listindd) 'v _ _))
  (def (g x) '(sylib hoareCfg_T1 @ exp @
    sylib (hoareCfg_biim1a @ ss_s_weak s_anl) @
    syl5 anl @ exp ,x))
  (focus
    '(iald @ iald @ iald @ iald @ expcom ,(g _))
    '(sylc hoareCfg_id2 (nseqd @ sneqd @ syl6eq set_getMemory @ setMemoryeq2d @ anld @
        sylib prth @ eqtr3d an3lr @ sylan setMem0 (syl getMemoryT anlr) (anwr @ u64le1 leaddid1)) @
      mpbiri s_weak_id @ s_weakeq1d @ syl6eqs (eqstr4 s_mem_0 s_mem_0) @
      s_memeq3d @ sylib leneq0 @ syl6eq len0 an4lr))
  '(sylibr (cbval @ cbvald @ cbvald @ cbvald ,eqtac) @ iald @ iald @ !! iald l @ ialda ,(g _))
  '(mpd (sylib excons @ sylib (noteq leneq0) @ syl sucne0 @ syl6eq lenS @ rsyl anllr anlr) @
    eexd @ eexda @ sylbi (bian21i @ bian21i anrass) @ imp @ mpbird (anwr ,eqtac) @
    sylbid (aneqd (a1i @ aneq elListS @ bitr (eqeq lenS lenS) peano2) @
      eqeq1d @ sylan (mpi (eqcom fstsnd) setMemS)
        (syl getMemoryT anllr) (rsyl anlr @ u64le1 leaddid1)) _)
  (have 'H1
    '(syl contra @ com12 @ sylbid (eqeq1d ifneg) @ a1i @ sylbi prth anr))
  '(syl5 (anim2 @ iand H1 @ eqtr3d (syl ifpos H1) id) @ exp @
    sylibr (hoareCfgeq eqid (nseq @ sneq @ eqcom set_setMemory) s_mem_S s_mem_S) @
    hoareCfg_tr1 (syl hoareCfg_frame_r _) (syl hoareCfg_frame _))
  (focus
    '(sylc hoareCfg_weakr _ @ syl hoareCfg_exim @ ialda @
      rsyl anlr @ s_mem1_hoareCfg an3l @ syl5eqr fstsnd @ preq2d anrl)
    '(anw5l @ syl ss_s_weak @ iald @ sylibr (imeqi el_s_ex el_s_ex) @
      eximd @ syl5bi (aneq2i @ el_s_anlift1 s_mem1_sstop) @
      syl5bir anass @ anim1d @ impd @ com23 @ exp @ sylibr (imeqi elrapp elrapp) h3))
  (focus
    '(mpd (iand (anwr @ iand anllr anlr) @ eqtrd _ @ anwr anrr) @
      rsyl an4lr @ ealie @ ealde @ ealde @ ealde @ bi1d ,eqtac)
    '(setMemeqd (a1i get_setMemory) (eqcomd @ syl add64S_eqid _) eqidd)
    '(sylc u64le1 (sylib (leeq1 add12) @ sylib leadd2 @
        mpbiri le11S @ leeq2d @ syl6eq lenS @ leneqd anlr) anllr)));

--| A block of readable or read/write memory: `a >=> v` says that the
--| list of bytes `v` is at address `a`.
@_ local def s_block (a v): set = $ s_mem (S\ x, {p | PROT_READ C_ p}) a v $;
infixl s_block: $>=>$ prec 80;

theorem s_block_sstop: $ a >=> v C_ T.s $ = (named '(sstr s_anl s_lift_sstop));
theorem s_block_T: $ a >=> v C_ ^s (a + len v e. u64 /\ v e. List u8) $ = (named 's_mem_T);
theorem s_block_T2: $ k |=s a >=> v -> a + len v e. u64 /\ v e. List u8 $ = (named 's_mem_T2);
theorem s_block_0: $ a >=> 0 == ^e (a e. u64) $ = (named 's_mem_0);
theorem s_block_A: $ len v = n -> a >=> v ++ w == a >=> v *s (a + n) >=> w $ = (named 's_mem_A);

theorem s_readMemory:
  $ k |=s a >=> v -> readMemory PROT_READ (getMemory (ksCfg k)) a v $ =
(named '(s_mem_readMemory (a1i PROT_READ_T) id @
  a1i @ ax_gen @ bi1 @ elsabe @ elabed ,eqtac));

theorem s_readMem: $ k |=s a >=> v -> readMem (ksCfg k) a v $ =
'(iand (syl ksCfgT s_sat_ks) s_readMemory);
theorem s_readMem_d (h: $ G -> P =>*s a >=> v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readMem k a v $ =
'(mpbid (readMemeq1d anlr) @ syl s_readMem @ imp @ anwl @ syl s_weak_sat h);

--| A block of executable code: `a >=>c v` says that the
--| list of bytes `v` is at address `a`.
@_ local def s_code (a v): set = $ s_mem (S\ x, {p | PROT_READ + PROT_EXEC C_ p}) a v $;
infixl s_code: $>=>c$ prec 80;

theorem s_code_sstop: $ a >=>c v C_ T.s $ = (named '(sstr s_anl s_lift_sstop));
theorem s_code_T: $ a >=>c v C_ ^s (a + len v e. u64 /\ v e. List u8) $ = (named 's_mem_T);
theorem s_code_T2: $ k |=s a >=>c v -> a + len v e. u64 /\ v e. List u8 $ = (named 's_mem_T2);
theorem s_code_0: $ a >=>c 0 == ^e (a e. u64) $ = (named 's_mem_0);
theorem s_code_A: $ len v = n -> a >=>c v ++ w == a >=>c v *s (a + n) >=>c w $ = (named 's_mem_A);
theorem s_code_weakl: $ a >=>c v ++ w =>*s a >=>c v $ =
'(mpbir (s_weakeq1 @ s_code_A eqid) s_sepl);
theorem s_code_weakr: $ len v = n -> a >=>c v ++ w =>*s (a + n) >=>c w $ =
'(mpbiri s_sepr (s_weakeq1d s_code_A));

theorem s_readMemory_RX:
  $ k |=s a >=>c v ->
    readMemory (PROT_READ + PROT_EXEC) (getMemory (ksCfg k)) a v $ =
(named '(s_mem_readMemory (a1i PROT_RX_T) id @
  a1i @ ax_gen @ bi1 @ elsabe @ elabed ,eqtac));

theorem s_readMemX: $ k |=s a >=>c v -> readMemX (ksCfg k) a v $ =
'(iand (syl ksCfgT s_sat_ks) s_readMemory_RX);
theorem s_readMemX_d (h: $ G -> P =>*s a >=>c v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readMemX k a v $ =
'(mpbid (readMemXeq1d anlr) @ syl s_readMemX @ sylc s_weak_sat (anwll h) anr);

theorem s_code_assembled (h: $ assembled c s x y $):
  $ text_start >=>c c =>*s x >=>c s /\ x + len s = y $ =
(named @ focus
  '(iani (eex (mpbird (s_weakeq2d @ s_codeeq1d anl) _) @ anri h) @ eqcom @ anlr h)
  '(anwr @ eex @ eex @ mpbird (s_weakeq1d @ s_codeeq2d anl) @
    syl (mpi s_code_weakl s_weak_tr) (anwr s_code_weakr)));

--| A block of uninitialized memory: `a >=>. n` says that there are
--| `n` free bytes at address `a`.
--| The bytes can be written to but not read until first write.
@_ local def s_block0 (a n): set = $ E.s v e. Array u8 n, s_mem _V a v $;
infixl s_block0: $>=>.$ prec 80;

theorem s_block0_sstop: $ a >=>. n C_ T.s $ = (named '(s_eex s_mem_sstop));
theorem s_block0_T: $ a >=>. n C_ ^s (a + n e. u64) $ =
(named '(mpbi s_eexb @ ax_gen @ syl (sstr s_mem_T) @ sylibr s_lift_ss @
  syl5 anl @ bi1d @ eleq1d @ addeq2d elArraylen));
theorem s_block0_T2: $ k |=s a >=>. n -> a + n e. u64 $ = '(s_sat_ss_lift s_block0_T);
theorem s_block0_0: $ a >=>. 0 == ^e (a e. u64) $ =
(named '(eqstr (s_exeq1 @ ax_gen @ bitr4 elArray02 elsn) @
  trud @ s_exeqe @ syl6eqs s_mem_0 ,eqtac));

theorem s_block0_A_lem:
  $ E.s z e. Array u8 (m + n), s_mem P a z ==
    E.s x e. Array u8 m, s_mem P a x *s
    E.s y e. Array u8 n, s_mem P (a + m) y $ =
(focus
  '(eqstr (ssasym _ _) @ eqstr (s_exeq2i s_exsep1) s_exsep2)
  (focus
    (have 'H '(syl takeArray @ ian leaddid1))
    '(mpbi s_eexb @ ax_gen @
      syl s_iex @ sylan (iexe ,eqtac) H @
      syl s_iex @ sylan (iexe ,eqtac) dropArray @
      sylib (sseq1 @ s_memeq3 takedrop) @
      syl eqss @ syl s_mem_A @ rsyl H elArraylen))
  (focus
    '(mpbi s_eexb @ ax_gen @ sylib s_eexb @ ialda @
      syl s_iex @ sylan (iexe ,eqtac) (imp appendArray) @
      syl eqssr @ syl s_mem_A @ anwl elArraylen)));

theorem s_block0_A: $ a >=>. (m + n) == a >=>. m *s (a + m) >=>. n $ = (named 's_block0_A_lem);

theorem s_mem_block0: $ s_mem P a v C_ a >=>. len v $ =
(named '(mpbi (sseq1 @ mpbi s_bian1a s_anl) @ s_imp @
  syl s_iex @ iexde @
  iand (mpbird (eleq1d anr) @ sylibr elArray @ iand anlr eqidd) @
  mpbiri (s_mem_ss @ ax_gen @ a1i @ rappss ssv2) ,eqtac));

theorem s_block_block0: $ a >=> v C_ a >=>. len v $ = (named 's_mem_block0);

--| A no-access memory heaplet: `s_blockZ a n` says that the memory at
--| `a ... a+n` is mapped but read-protected and will cause a fault if accessed.
@_ local def s_blockZ (a n): set = $ E.s v e. Array u8 n, s_mem (sn 0) a v $;

theorem s_blockZ_sstop: $ s_blockZ a n C_ T.s $ = (named '(s_eex s_mem_sstop));
theorem s_blockZ_T: $ s_blockZ a n C_ ^s (a + n e. u64) $ =
(named '(mpbi s_eexb @ ax_gen @ syl (sstr s_mem_T) @ sylibr s_lift_ss @
  syl5 anl @ bi1d @ eleq1d @ addeq2d elArraylen));
theorem s_blockZ_T2: $ k |=s s_blockZ a n -> a + n e. u64 $ = '(s_sat_ss_lift s_blockZ_T);
theorem s_blockZ_block0: $ s_blockZ a n C_ a >=>. n $ =
(named '(s_eximi @ a1i @ s_mem_ss @ ax_gen @ a1i @ rappss ssv2));
theorem s_blockZ_0: $ s_blockZ a 0 == ^e (a e. u64) $ =
(named '(eqstr (s_exeq1 @ ax_gen @ bitr4 elArray02 elsn) @
  trud @ s_exeqe @ syl6eqs s_mem_0 ,eqtac));
theorem s_blockZ_A: $ s_blockZ a (m + n) ==
  s_blockZ a m *s s_blockZ (a + m) n $ = (named 's_block0_A_lem);

--| `r >->r v` means that register `r e. Regs` contains value `v e. u64`.
@_ local def s_reg (r v): set =
$ ^s (r e. Regs /\ v e. u64) /\s sn (sn (X86P_Reg r <> v)) $;
infixl s_reg: $>->r$ prec 80;

theorem s_reg_sstop: $ r >->r v C_ T.s $ = '(sstr s_anl s_lift_sstop);
theorem s_reg_T: $ r >->r v C_ ^s (r e. Regs /\ v e. u64) $ = 's_anl;
theorem s_reg_T2: $ k |=s r >->r v -> r e. Regs /\ v e. u64 $ = '(s_sat_ss_lift s_reg_T);
theorem s_reg_subsn: $ subsn (r >->r v) $ = '(subsnss s_anr subsnsn);

theorem s_readReg: $ k |=s r >->r v -> readReg (ksCfg k) r = v $ =
'(syl5eqr read_place_Reg @ sylbi s_sat_anlift1 @ anwr @
  sylbi s_sat_sn @ sylbi heap_sat_sn anr);
theorem s_readReg_d (h: $ G -> P =>*s r >->r v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readReg k r = v $ =
'(eqtr3d (readRegeq1d anlr) @ syl s_readReg @ imp @ anwl @ syl s_weak_sat h);

theorem hoareCfg_setReg:
  $ v e. u64 -> hoareCfg k (sn (setReg k r v)) (r >->r w) (r >->r v) $ =
(named @ focus
  (have 'H '(anld @ sylib s_sat_anlift1 anr))
  '(hoareCfg_sn_d ,eqtac (a1i @ ss_s_weak s_anr)
    (sylan setRegT (iand (anwr @ syl ksCfgT s_sat_ks) @ anld H) anll)
    (a1i @ eqssr @ PageMappingeq getMemory_setReg)
    (anwr read_place_setReg_ne)
    (a1i @ eqtr read_place_Reg @ eqtr (readRegeq1 ksCfg_setCfg) read_setReg)
    (bi2d @ s_sateq2d @ s_sepeq2d @ sylan (s_bian1 @ mpbir s_sn_sstop isfsn)
      (anld H) anll)));

--| `flags>-> fl` means that the flags have value `fl`.
@_ local def s_flags (v): set = $ ^s (v e. Flags) /\s sn (sn (X86P_Flags <> v)) $;
prefix s_flags: $flags>->$ prec 80;

theorem s_flags_sstop: $ flags>-> fl C_ T.s $ = '(sstr s_anl s_lift_sstop);
theorem s_flags_T: $ flags>-> fl C_ ^s (fl e. Flags) $ = 's_anl;
theorem s_flags_T2: $ k |=s flags>-> fl -> fl e. Flags $ = '(s_sat_ss_lift s_flags_T);
theorem s_flags_subsn: $ subsn (flags>-> fl) $ = '(subsnss s_anr subsnsn);

theorem s_readFlags: $ k |=s flags>-> v -> readFlags (ksCfg k) = v $ =
'(syl5eqr read_place_Flags @ sylbi s_sat_anlift1 @ anwr @
  sylbi s_sat_sn @ sylbi heap_sat_sn anr);
theorem s_readFlags_d (h: $ P =>*s flags>-> v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readFlags k = v $ =
'(eqtr3d (readFlagseqd anlr) @ anwr @ syl s_readFlags @ s_weak_sat h);

theorem hoareCfg_writeFlags:
  $ v e. Flags -> hoareCfg k (sn (writeFlags k v)) (flags>-> fl) (flags>-> v) $ =
(named '(mpbird (hoareCfgeq4d @ s_bian1 @ mpbir s_sn_sstop isfsn) @
  hoareCfg_sn_d ,eqtac (a1i @ ss_s_weak s_anr)
    (sylan writeFlagsT (anwr @ syl ksCfgT s_sat_ks) anll)
    (a1i @ eqssr @ PageMappingeq getMemory_writeFlags)
    (anwr read_place_writeFlags_ne)
    (a1i @ eqtr read_place_Flags @ eqtr (readFlagseq ksCfg_setCfg) read_writeFlags)
    idd));

--| `flags>->.` means that the flags are clobbered.
@_ local def s_noflags: set = $ E.s fl e. Flags, flags>-> fl $;
prefix s_noflags: $flags>->.$ prec max;

theorem s_noflags_sstop: $ flags>->. C_ T.s $ = (named '(s_eex s_flags_sstop));

theorem s_flags_clob: $ flags>-> fl C_ flags>->. $ =
'(mpbi (sseq1 @ mpbi s_bian1a s_flags_T) @ s_imp @
  syl s_iex @ mpi ssid @ exp @ iexe ,eqtac);

theorem hoareCfg_writeFlags2:
  $ v e. Flags -> hoareCfg k (sn (writeFlags k v)) flags>->. (flags>-> v) $ =
(named '(sylib hoareCfg_eexb @ ialda @ anwl hoareCfg_writeFlags));

theorem hoareCfg_eraseFlags:
  $ hoareCfg k {k2 | eraseFlags k k2} flags>->. flags>->. $ =
(named '(mpbir hoareCfg_ab @ trud @ ialda @ ialda @
  mpbird (pimeq1d @ syl bian1 s_elConfig_d) @
  sylc pimtr (iand (syl (iexe ,eqtac) @ syl readFlagsT s_elConfig_d) @ iald idd) @
  ialda @ sylibr (pimeqe ,eqtac) @
  sylc hoareCfg_sn_frame_E (mpbird (hoareCfgeq1d anllr) @
    anwr @ syl (hoareCfg_weakr @ ss_s_weak s_flags_clob) hoareCfg_writeFlags2) anlr));

--| `s_CZSO c z s o` means that the CF,ZF,SF,OF flags are set to `c,z,s,o` respectively.
@_ local def s_CZSO (c z s o): set =
$ E.s fl e. Flags, (
  ^s ((CF fl <-> c) /\ (ZF fl <-> z) /\ (SF fl <-> s) /\ (OF fl <-> o)) /\s
  flags>-> fl) $;

theorem s_CZSO_sstop: $ s_CZSO c z s o C_ T.s $ = (named '(s_eex @ s_anwl s_lift_sstop));
theorem s_CZSO_clob: $ s_CZSO c z s o C_ flags>->. $ =
(named '(s_exim @ ax_gen @ a1i s_anr));

theorem hoareCfg_setCZSO:
  $ hoareCfg k (sn (setCZSO k c z s o)) flags>->. (s_CZSO c z s o) $ =
(named @ focus
  (have 'H '(syl setOF_T @ syl setSF_T @ syl setZF_T @ syl setCF_T @
    syl readFlagsT s_elConfig_d))
  '(trud @ hoareCfg_Td @ hoareCfg_iexe ,eqtac H @
    hoareCfg_iand (a1i @
      iani (iani (iani CF_setCZSO ZF_setCZSO) SF_setCZSO) OF_setCZSO) @
    syl hoareCfg_writeFlags2 H));

theorem s_CZSO_lem {fl} (q: wff fl)
  (h1: $ readFlags (ksCfg k) = fl -> (p <-> q) $)
  (h2: $ (CF fl <-> c) /\ (ZF fl <-> z) /\ (SF fl <-> s) /\ (OF fl <-> o) -> (q <-> r) $):
  $ k |=s s_CZSO c z s o -> (p <-> r) $ =
'(sylbi s_sat_ex @ eex @ imp @ syl5bi s_sat_anlift1 @ expcom @
  bitrd (syl h1 @ syl s_readFlags anlr) @ anwll h2);

theorem s_CZSO_CF: $ k |=s s_CZSO c z s o ->
  (CF (readFlags (ksCfg k)) <-> c) $ = '(!! s_CZSO_lem fl CFeq an3l);
theorem s_CZSO_ZF: $ k |=s s_CZSO c z s o ->
  (ZF (readFlags (ksCfg k)) <-> z) $ = '(!! s_CZSO_lem fl ZFeq anllr);
theorem s_CZSO_SF: $ k |=s s_CZSO c z s o ->
  (SF (readFlags (ksCfg k)) <-> s) $ = '(!! s_CZSO_lem fl SFeq anlr);
theorem s_CZSO_OF: $ k |=s s_CZSO c z s o ->
  (OF (readFlags (ksCfg k)) <-> o) $ = '(!! s_CZSO_lem fl OFeq anr);

--| `s_resultFlags sz w c o` means that the ZF and SF flags are set according to the
--| result `w` (of size `sz`), and the CF and OF flags are set to `c,o`.
@_ local def s_resultFlags (sz w c o): set =
$ ^s (sz e. WSize /\ w e. u64) /\s s_CZSO c (chop (wsizeBits sz) w = 0) (MSB sz w) o $;

theorem s_resultFlags_sstop: $ s_resultFlags sz w c o C_ T.s $ = '(s_anwl s_lift_sstop);
theorem s_resultFlags_T: $ s_resultFlags sz w c o C_ ^s (sz e. WSize /\ w e. u64) $ = 's_anl;
theorem s_resultFlags_clob: $ s_resultFlags sz w c o C_ flags>->. $ = '(s_anwr s_CZSO_clob);

theorem hoareCfg_writeResultFlags:
  $ sz e. WSize /\ w e. u64 ->
    hoareCfg k (sn (writeResultFlags k sz w c o)) flags>->. (s_resultFlags sz w c o) $ =
'(hoareCfg_iand id @ a1i hoareCfg_setCZSO);

theorem s_resultFlags_CF:
  $ k |=s s_resultFlags sz w c o -> (CF (readFlags (ksCfg k)) <-> c) $ =
'(sylbi s_sat_anlift1 @ anwr s_CZSO_CF);
theorem s_resultFlags_ZF:
  $ k |=s s_resultFlags sz w c o -> (ZF (readFlags (ksCfg k)) <-> chop (wsizeBits sz) w = 0) $ =
'(sylbi s_sat_anlift1 @ anwr s_CZSO_ZF);
theorem s_resultFlags_SF:
  $ k |=s s_resultFlags sz w c o -> (SF (readFlags (ksCfg k)) <-> MSB sz w) $ =
'(sylbi s_sat_anlift1 @ anwr s_CZSO_SF);
theorem s_resultFlags_OF:
  $ k |=s s_resultFlags sz w c o -> (OF (readFlags (ksCfg k)) <-> o) $ =
'(sylbi s_sat_anlift1 @ anwr s_CZSO_OF);

--| `s_addFlags sz a b` means that the flags are set according to a
--| previous addition `a + b`.
@_ local def s_addFlags (sz a b): set =
$ ^s (a e. u64 /\ b e. u64) /\s s_resultFlags sz (a +_64 b)
    (2 ^ wsizeBits sz <= a + b)
    ((MSB sz a <-> MSB sz b) /\ ~(MSB sz (a +_64 b) <-> MSB sz a)) $;

theorem s_addFlags_sstop: $ s_addFlags sz a b C_ T.s $ = '(s_anwl s_lift_sstop);
theorem s_addFlags_T: $ s_addFlags sz a b C_ ^s (sz e. WSize /\ a e. u64 /\ b e. u64) $ =
'(mpbi (sseq2 @ eqstr4 s_lift_an (s_lifteq anass)) @ mpbir s_ian @
  iani (s_anwr @ sstr s_resultFlags_T @ mpbir s_lift_ss anl) s_anl);
theorem s_addFlags_clob: $ s_addFlags sz a b C_ flags>->. $ = '(s_anwr s_resultFlags_clob);

theorem hoareCfg_addFlags:
  $ addCarry sz a b w (nat c) (nat o) ->
    hoareCfg k (sn (writeResultFlags k sz w c o)) flags>->. (s_addFlags sz a b) $ =
'(hoareCfg_iand (iand an4lr an3lr) @
  mpbird (rsyl (anim (anim anr @ bi2i natinj) @ bi2i natinj) @ hoareCfgeq2d ,eqtac) @
  sylan hoareCfg_writeResultFlags an5l (a1i add64T));

--| `s_subFlags sz a b` means that the flags are set according to a
--| previous subtraction `a - b`.
@_ local def s_subFlags (sz a b): set =
$ ^s (a e. u64 /\ b e. u64) /\s s_resultFlags sz (a -_64 b)
    (a < b)
    (~(MSB sz a <-> MSB sz b) /\ ~(MSB sz (a -_64 b) <-> MSB sz a)) $;

theorem s_subFlags_sstop: $ s_subFlags sz a b C_ T.s $ = '(s_anwl s_lift_sstop);
theorem s_subFlags_T: $ s_subFlags sz a b C_ ^s (sz e. WSize /\ a e. u64 /\ b e. u64) $ =
'(mpbi (sseq2 @ eqstr4 s_lift_an (s_lifteq anass)) @ mpbir s_ian @
  iani (s_anwr @ sstr s_resultFlags_T @ mpbir s_lift_ss anl) s_anl);
theorem s_subFlags_clob: $ s_subFlags sz a b C_ flags>->. $ = '(s_anwr s_resultFlags_clob);

theorem hoareCfg_subFlags:
  $ subBorrow sz a b w (nat c) (nat o) ->
    hoareCfg k (sn (writeResultFlags k sz w c o)) flags>->. (s_subFlags sz a b) $ =
'(hoareCfg_iand (iand an4lr an3lr) @
  mpbird (rsyl (anim (anim anr @ bi2i natinj) @ bi2i natinj) @ hoareCfgeq2d ,eqtac) @
  sylan hoareCfg_writeResultFlags an5l (a1i add64T));

--| `RIP>-> a` means that the instruction pointer has value `a`.
@_ local def s_RIP (a): set = $ ^s (a e. u64) /\s sn (sn (X86P_RIP <> a)) $;
prefix s_RIP: $RIP>->$ prec 80;

theorem s_RIP_sstop: $ RIP>-> ip C_ T.s $ = '(sstr s_anl s_lift_sstop);
theorem s_RIP_T: $ RIP>-> ip C_ ^s (ip e. u64) $ = 's_anl;
theorem s_RIP_T2: $ k |=s RIP>-> ip -> ip e. u64 $ = '(s_sat_ss_lift s_RIP_T);
theorem s_RIP_subsn: $ subsn (RIP>-> ip) $ = '(subsnss s_anr subsnsn);

theorem s_readRIP: $ k |=s RIP>-> ip -> readRIP (ksCfg k) = ip $ =
'(syl5eqr read_place_RIP @ sylbi s_sat_anlift1 @ anwr @
  sylbi s_sat_sn @ sylbi heap_sat_sn anr);
theorem s_readRIP_d (h: $ P =>*s RIP>-> ip $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readRIP k = ip $ =
'(eqtr3d (readRIPeqd anlr) @ anwr @ syl s_readRIP @ s_weak_sat h);

theorem hoareCfg_writeRIP:
  $ v e. u64 -> hoareCfg k (sn (writeRIP k v)) (RIP>-> ip) (RIP>-> v) $ =
(named '(mpbird (hoareCfgeq4d @ s_bian1 @ mpbir s_sn_sstop isfsn) @
  hoareCfg_sn_d ,eqtac (a1i @ ss_s_weak s_anr)
    (sylan writeRIP_T (anwr @ syl ksCfgT s_sat_ks) anll)
    (a1i @ eqssr @ PageMappingeq getMemory_writeRIP)
    (anwr read_place_writeRIP_ne)
    (a1i @ eqtr read_place_RIP @ eqtr (readRIPeq ksCfg_setCfg) read_writeRIP)
    idd));

theorem s_writeRIP: $ v e. u64 -> k |=s R *s RIP>-> ip ->
  setCfg k (writeRIP (ksCfg k) v) |=s R *s RIP>-> v $ =
'(syl hoareCfg_sn_frame_E hoareCfg_writeRIP);

--| `s_Except e` means that the exception flag has value `e`.
@_ local def s_Except (e): set = $ sn (sn (X86P_Except <> e)) $;
@_ local def s_OK: set = $ s_Except 0 $;
@_ local def s_IO: set = $ s_Except (suc exSysCall) $;
@_ local def s_ERR: set = $ s_Except (suc exGPF) $;

theorem s_Except_sstop: $ s_Except e C_ T.s $ = '(mpbir s_sn_sstop isfsn);
theorem s_OK_sstop: $ s_OK C_ T.s $ = 's_Except_sstop;
theorem s_IO_sstop: $ s_IO C_ T.s $ = 's_Except_sstop;
theorem s_ERR_sstop: $ s_ERR C_ T.s $ = 's_Except_sstop;
theorem s_Except_subsn: $ subsn (s_Except e) $ = 'subsnsn;
theorem s_OK_subsn: $ subsn s_OK $ = 's_Except_subsn;
theorem s_IO_subsn: $ subsn s_IO $ = 's_Except_subsn;
theorem s_ERR_subsn: $ subsn s_ERR $ = 's_Except_subsn;

theorem s_Except_readException: $ k |=s s_Except e -> readException (ksCfg k) = e $ =
'(syl5eqr read_place_Except @ sylbi s_sat_sn @ sylbi heap_sat_sn anr);
theorem s_OK_readException: $ k |=s s_OK -> readException (ksCfg k) = 0 $ = 's_Except_readException;
theorem s_IO_readException: $ k |=s s_IO -> readException (ksCfg k) = suc exSysCall $ = 's_Except_readException;
theorem s_ERR_readException: $ k |=s s_ERR -> readException (ksCfg k) = suc exGPF $ = 's_Except_readException;
theorem s_Except_readException_d (h: $ P =>*s s_Except e $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readException k = e $ =
'(eqtr3d (readExceptioneqd anlr) @ anwr @ syl s_Except_readException @ s_weak_sat h);
theorem s_OK_readException_d (h: $ P =>*s s_OK $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readException k = 0 $ = '(s_Except_readException_d h);
theorem s_IO_readException_d (h: $ P =>*s s_IO $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readException k = suc exSysCall $ = '(s_Except_readException_d h);
theorem s_ERR_readException_d (h: $ P =>*s s_ERR $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readException k = suc exGPF $ = '(s_Except_readException_d h);

theorem hoareCfg_writeException (h: $ e2 e. Option Exception $):
  $ hoareCfg k (sn (setException k e2)) (s_Except e1) (s_Except e2) $ =
(named '(trud @ hoareCfg_sn ,eqtac
  (sylan setExceptionT (anwr ksCfgT) (a1i h))
  (a1i @ eqssr @ PageMappingeq getMemory_setException)
  (anwr read_place_setException_ne)
  (a1i @ eqtr read_place_Except @
    eqtr (readExceptioneq ksCfg_setCfg) read_setException)));

theorem s_readRegSz_8 (h1: $ b \/ ~2 e. r $) (h: $ G -> readReg k r = v $):
  $ G -> readRegSz k (wSz8 b) r = chop 8 v $ =
'(chopeqd (a1i wSz8Bits) @ syl5eq (ifneg @ mpbir notan @
    orim1 (con2 @ sylbi prth @ anwr @ bi1i @ bitr (eqeq2 nat0) nateq0) h1) h);
theorem s_readRegSz_gt8 (h1: $ wsizeBits sz = n $) (h2: $ 8 < n $)
  (h: $ G -> readReg k r = v $): $ G -> readRegSz k sz r = chop n v $ =
'(chopeqd (a1i h1) @
  syl5eq (ifneg @ mt (anwl @ eqtr3g h1 wSz8Bits wsizeBitseq) @ ltner h2) h);
theorem s_readRegSz_16 (h: $ G -> readReg k r = v $):
  $ G -> readRegSz k wSz16 r = chop 16 v $ = '(s_readRegSz_gt8 wSz16Bits d8lt16 h);
theorem s_readRegSz_32 (h: $ G -> readReg k r = v $):
  $ G -> readRegSz k wSz32 r = chop 32 v $ = '(s_readRegSz_gt8 wSz32Bits d8lt32 h);
theorem s_readRegSz_64 (h: $ G -> readReg k r = v $):
  $ G -> readRegSz k wSz64 r = chop 64 v $ = '(s_readRegSz_gt8 wSz64Bits d8lt64 h);
theorem s_readRegSz_64_ (h1: $ G -> P =>*s r >->r v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readRegSz k wSz64 r = v $ =
(focus
  (have 'H '(s_readReg_d h1))
  '(eqtrd (s_readRegSz_64 H) @ syl Bits_chop @ mpbid (eleq1d H) @
    sylan readRegT s_elConfig_d @ anld @
    syl s_reg_T2 @ imp @ anwl @ syl s_weak_sat h1));

theorem s_readEA_i (h1: $ G -> q e. u64 $) (h2: $ G -> sz e. WSize $)
  (h3: $ G -> v = chop (wsizeBits sz) q $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readEA k sz (EA_i q) v $ =
'(mpbird (sylan readEA_i (iand s_elConfig_d (anwll h1)) (anwll h2)) (anwll h3));

theorem s_readEA_r (h1: $ G -> r e. Regs $) (h2: $ G -> sz e. WSize $)
  (h3: $ G /\ ksCfg ks = k /\ ks |=s P -> readRegSz k sz r = v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readEA k sz (EA_r r) v $ =
'(mpbird (sylan readEA_r (iand s_elConfig_d (anwll h1)) (anwll h2)) @ eqcomd h3);

theorem an2idms (h: $ G /\ a /\ b /\ a /\ b -> c $): $ G /\ a /\ b -> c $ =
'(rsyl (iand (iand id anlr) anr) h);

theorem s_readEA64_r (h1: $ G -> P =>*s r >->r v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readEA64 k (EA_r r) v $ =
'(an2idms @ s_readEA_r (anld @ syl s_reg_T2 @ imp @ anwl @ syl s_weak_sat h1)
    (a1i wSz64T) (anwll @ s_readRegSz_64_ h1));

theorem s_readEA_m (hn: $ wsizeBits sz = n $) (hm: $ wsizeBytes sz = m $)
  (ha: $ G -> a e. u64 $) (hsz: $ G -> sz e. WSize $)
  (hv: $ G -> v e. Bits n $) (hP: $ G -> P =>*s a >=> toBytes m v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readEA k sz (EA_m a) v $ =
'(mpbird (sylan readEA_m (iand s_elConfig_d (anwll ha)) (anwll hsz)) @
  iand (anwll @ sylibr (eleq2 @ nseq @ Bitseq hn) hv) @
  sylibr (readMemeq3 @ toByteseq1 hm) @ s_readMem_d hP);

theorem s_readEA64_m (ha: $ G -> a e. u64 $)
  (hv: $ G -> v e. u64 $) (hP: $ G -> P =>*s a >=> u64Bytes v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readEA64 k (EA_m a) v $ =
'(s_readEA_m wSz64Bits wSz64Bytes ha (a1i wSz64T) hv hP);

theorem hoare_decode_step {k}
  (h1: $ G -> P =>*s ip >=>c l $)
  (h2: $ G -> decode ast l $)
  (h3: $ G -> ip + len l = ip2 $)
  (h4: $ G -> hoareCfg k {k2 | execXAST k ast k2} (RIP>-> ip2 *s s_OK *s P) Q $)
     : $ G -> hoare T (RIP>-> ip *s s_OK *s P) Q $ =
(named @ focus
  (have 'H1 '(s_readRIP_d @ s_sepwl s_sepl))
  (have 'H2 '(imp @ anwl @ syl s_weak_sat @ syl s_sepwr h1))
  (have 'H3 '(anld @ syl s_code_T2 H2))
  '(hoareCfg_step @
    mpbird (hoareCfgeq2da @
      bitrd (sylan decode_step
        (mpbird (readMemXeq2d H1) @ s_readMemX_d @ syl s_sepwr h1) (anwll h2)) @
      bitrd (syl bian1 @ s_OK_readException_d @ s_sepwl s_sepr) @
      execXASTeq1d @ writeRIPeq2d @ eqtrd (add64eq1d H1) @
      eqtrd (syl add64_eqid H3) @ anwll h3) @
    hoareCfg_Td @ hoareCfg_tr1
      (syl hoareCfg_frame_r @ syl hoareCfg_frame_r @
        syl hoareCfg_writeRIP @ mpbid (anwll @ eleq1d h3) H3)
      (anwll @ !! sbeth k h4 ,eqtac)));

-- theorem hoareCfg_writeCFOFResult
--   (h1: $ G -> hoareCfg k {k2 | writeEA k sz ea w k2} P Q $):
--   $ G -> hoareCfg k {k2 | writeCFOFResult k sz ea w c o k2}
--       (flags>->. *s P) (s_resultFlags sz w c o *s Q) $ =
-- _;

theorem hoareCfg_popAux
  (h1: $ G -> q e. u64 $)
  (h2: $ G -> P =>*s sp >=> u64Bytes q $)
  (h3: $ G -> sp +_64 8 = sp2 $):
  $ G -> hoareCfg k {k2 | popAux k q k2} (RSP >->r sp *s P) (RSP >->r sp2 *s P) $ =
(named '(mpbird (hoareCfgeq2da @
    bitrd (syl bian1 @
      mpbird (readEA64eq2d @ EA_meqd @ s_readReg_d @ a1i s_sepl) @
      an2idms @ s_readEA64_m (anrd @ syl s_reg_T2 @ anwr @ s_weak_sat s_sepl)
        (anwll h1) (anwll @ syl s_sepwr h2)) @
    eqeq2d @ setRegeq3d @ eqtrd (add64eq1d @ s_readReg_d @ a1i s_sepl) (anwll h3)) @
  sylib (hoareCfgeq2 @ eqab2i elsn) @ syl hoareCfg_frame_r @ syl hoareCfg_setReg @
  mpbii add64T @ eleq1d h3));

theorem hoareCfg_popRIP
  (h1: $ G -> q e. u64 $)
  (h2: $ G -> P =>*s sp >=> u64Bytes q $)
  (h3: $ G -> sp +_64 8 = sp2 $):
  $ G -> hoareCfg k {k2 | popRIP k k2}
    (RSP >->r sp *s RIP>-> ip *s P) (RSP >->r sp2 *s RIP>-> q *s P) $ =
(named @ focus
  (def H '(hoareCfg_popAux h1 (syl s_sepwr h2) h3))
  '(sylibr (hoareCfgeq eqid eqsid s_sepass s_sepass) @
    mpbid (hoareCfgeq2da @ mpd (hoareCfg_E_ex ,H) @ eexda @
      exeqd @ syl5bbr _ @ exeqd @
      syl bian1a @ anwr @ syl5 anl @ expcom @ anld popAux_determ) _)
  '(exeqe ,eqtac)
  '(hoareCfg_tr ,H @ anwl @ sylib (hoareCfgeq2 @ eqab2i elsn) @
    syl hoareCfg_frame @ syl hoareCfg_frame_r @ syl hoareCfg_writeRIP h1));

theorem hoareCfg_xastRet
  (h1: $ G -> sp +_64 q = sp2 $)
  (h2: $ G -> hoareCfg k {ki | popRIP k ki} P (RSP >->r sp *s Q) $)
  : $ G -> hoareCfg k {k2 | execXAST k (xastRet q) k2} P (RSP >->r sp2 *s Q) $ =
(named '(mpbird (hoareCfgeq2da @ a1i execXASTRet) @
  hoareCfg_tr h2 @ sylib (hoareCfgeq2 @ eqab2i elsn) @
  syl hoareCfg_frame_r @ hoareCfg_Td @
  mpbird (hoareCfgeq2d @ nseqd @ sneqd @ setRegeq3d @
    eqtrd (add64eq1d @ s_readReg_d @ a1i s_weak_id) (anw3l h1)) @
  syl hoareCfg_setReg @
  mpbii add64T @ eleq1d @ anw3l h1));

theorem hoareCfg_xastRet0
  (h1: $ G -> q e. u64 $)
  (h2: $ G -> P =>*s sp >=> u64Bytes q $)
  (h3: $ G -> sp +_64 8 = sp2 $):
  $ G -> hoareCfg k {k2 | execXAST k (xastRet 0) k2}
    (RSP >->r sp *s RIP>-> ip *s P) (RSP >->r sp2 *s RIP>-> q *s P) $ =
(named '(sylibr (hoareCfgeq4 s_sepass) @
  hoareCfg_xastRet (syl6eq add0 @ syl add64_eqid @
    mpbii add64T (eleq1d @ syl6eqr add0 h3)) @
  sylib (hoareCfgeq4 s_sepass) @ hoareCfg_popRIP h1 h2 h3));

theorem hoareCfg_xastBinop {ks}
  (head: $ destEA k ds = ead $)
  (heas: $ srcEA k ds = eas $)
  (h1: $ G /\ ksCfg ks = k /\ ks |=s P -> readEA k sz ead d $)
  (h2: $ G /\ ksCfg ks = k /\ ks |=s P -> readEA k sz eas s $)
  (h3: $ G -> hoareCfg k {k2 | writeBinop k op sz ead d s k2} P Q $):
  $ G -> hoareCfg k {k2 | execXAST k (xastBinop op sz ds) k2} P Q $ =
(focus
  '(hoareCfg_Td @ mpbird (hoareCfgeq2d @ abeqd @ syl5bb execXASTBinop _) (anwll h3))
  '(syl5bb (exeqi @ bian1exi anass) @ bitrd _ @ syl6bb (writeBinopeq4 head) _)
  '(rsyl (sylibr (readEAeq3 head) h1) @ determ_exeqe ,eqtac ,eqtac readEA_determ)
  '(rsyl (sylibr (readEAeq3 heas) h2) @ determ_exeqe ,eqtac ,eqtac readEA_determ));

-- theorem hoareCfg_xastBinopAdd {ks}
--   (head: $ destEA k ds = ead $)
--   (heas: $ srcEA k ds = eas $)
--   (h1: $ G /\ ksCfg ks = k /\ ks |=s P -> readEA k sz ead d $)
--   (h2: $ G /\ ksCfg ks = k /\ ks |=s P -> readEA k sz eas s $)
--   (h3: $ G -> d +_64 s = w $)
--   (h4: $ G -> hoareCfg k {k2 | writeEA k sz ead w k2} P Q $):
--   $ G -> hoareCfg k {k2 | execXAST k (xastBinop binopAdd sz ds) k2}
--       (flags>->. *s P) (s_addFlags sz d s *s Q) $ =
-- _;

--| An unallocated stack block. Here `lo` is a parameter, representing the base of the
--| stack. The bytes within one page of the stack base have no access, otherwise
--| it is read/write data (we don't track write access).
--|
--| The upshot of this encoding is that writing to the memory is safe, and doing so
--| obtains a proof that `lo + 2 ^ 12 <= a`, because accessing the guard page
--| would have caused a crash. We can later merge the proof that `lo + 2 ^ 12 <= a` with
--| readable memory to return it to deallocated state.
@_ local def s_blockS (lo a n): set =
$ E.s v e. Array u8 n, s_mem (S\ x, {p |
    ifp (lo + 2 ^ 12 <= x) (PROT_READ C_ p) (p = 0)}) a v $;
notation s_blockS (lo a n): set = a ($>=>.[$:80) lo ($]$:0) n: 80 lassoc;

theorem s_blockS_sstop: $ a >=>.[lo] n C_ T.s $ = (named '(s_eex s_mem_sstop));
theorem s_blockS_T: $ a >=>.[lo] n C_ ^s (a + n e. u64) $ =
(named '(mpbi s_eexb @ ax_gen @ syl (sstr s_mem_T) @ sylibr s_lift_ss @
  syl5 anl @ bi1d @ eleq1d @ addeq2d elArraylen));
theorem s_blockS_T2: $ k |=s a >=>.[lo] n -> a + n e. u64 $ = '(s_sat_ss_lift s_blockS_T);
theorem s_blockS_0: $ a >=>.[lo] 0 == ^e (a e. u64) $ =
(named '(eqstr (s_exeq1 @ ax_gen @ bitr4 elArray02 elsn) @
  trud @ s_exeqe @ syl6eqs s_mem_0 ,eqtac));
theorem s_blockS_A: $ a >=>.[lo] (m + n) ==
  a >=>.[lo] m *s (a + m) >=>.[lo] n $ = (named 's_block0_A_lem);
theorem s_blockS_block0: $ a >=>.[lo] n C_ a >=>. n $ =
(named '(s_eximi @ a1i @ s_mem_ss @ ax_gen @ a1i @ rappss ssv2));

theorem s_block_blockS: $ lo + 2 ^ 12 <= a -> a >=> v C_ a >=>.[lo] len v $ =
(named '(sylib (sseq1 @ mpbi s_bian1a s_anl) @ syl s_imp @ expcom @
  syl s_iex @ iexde @
  iand (mpbird (eleq1d anr) @ sylibr elArray @ iand anllr eqidd) @
  mpbird ,eqtac (syl s_mem_ss @ ialda @
    sylibr (sseq (rappsabe ,eqtac) (rappsabe ,eqtac)) @ ssabd @
    bi2d @ syl ifppos @ syl (mpi leaddid1 letr) anllr)));

-- --| The unused portion of the stack, which contains an arbitrary block of
-- --| read/write data followed by a no-access guard page.
-- --|
-- --| `unused_stack lo sz` means that there are `sz` bytes of stack, such that
-- --| the low `min sz 4096` bytes of it are read protected, and the rest has
-- --| arbitrary readable memory.
-- @_ local def unused_stack (lo sz): set =
-- $ s_blockZ lo (min sz (2 ^ 12)) *s (lo + 2 ^ 12) >=>. (sz - 2 ^ 12) $;

-- theorem unused_stack_lo: $ sz <= 2 ^ 12 ->
--   unused_stack lo sz == ^s (lo + 2 ^ 12 e. u64) /\s s_blockZ lo sz $ =
-- '(syl6eqs s_sep_elift @ s_sepeqd (s_blockZeq2d eqmin1) @
--   syl6eqs s_block0_0 @ s_block0eq2d @ bi1i lesubeq0);

-- theorem unused_stack_hi:
--   $ unused_stack lo (sz + 2 ^ 12) == s_blockZ lo (2 ^ 12) *s (lo + 2 ^ 12) >=>. sz $ =
-- '(s_sepeq (s_blockZeq2 @ eqmin2 leaddid2) (s_block0eq2 pncan));

-- theorem s_dealloc_stack_lem:
--   $ s_mem P hi v *s unused_stack lo sz C_ unused_stack lo (sz + len v) $ =
-- (focus
--   '(_)
-- );

-- theorem s_dealloc_stack:
--   $ (lo + sz) >=>. n *s unused_stack lo sz C_ unused_stack lo (sz + n) $ =
-- (focus
--   '(eor _ _ leorle)
--   '(mpbii (s_sep_ss2 @ eqssr @ eqstr s_block0_A s_sepcom) @
--     sseqd (syl5eqs s_seplass @
--       s_sepeqd (s_block0eq1d @ syl5eq addass @ addeq2d pncan3) @
--         syl5eqsr unused_stack_hi @ unused_stackeq2d npcan) @
--     syl5eqsr unused_stack_hi @ unused_stackeq2d @ syl5eq addrass @ addeq1d npcan)
--   '(mpbird (sseq1d @ s_sepeq2d unused_stack_lo) @ mpi leorle @ eorda _ _)
-- );

-- --| `unused_stack_bd hi sz` means that there are at least `sz` bytes of stack
-- --| "above" `hi` (the top of the stack). Note that the stack grows down so these
-- --| unused bytes are at lower addresses than `hi`, and `hi` itself is not included.
-- --|
-- --| This means in particular that writing to any element up to `sz` bytes above `hi`
-- --| is safe, because we know it is either allocated or guarded.
-- @_ local def unused_stack_bd (lo hi sz): set =
-- $ ^s (lo + sz <= hi /\ lo <= hi) /\s s_blockS lo lo (hi - lo) $;

-- theorem unused_stack_le2:
--   $ sz2 <= sz -> unused_stack_bd hi sz C_ unused_stack_bd hi sz2 $ =
-- (named '(s_eximd @ syl s_anim1 @
--   sylibr s_lift_ss @ anim1d @ syl letr @ sylib leadd2 anl));

-- theorem s_mem_dealloc_stack_bd:
--   $ s_mem P hi v *s unused_stack_bd hi sz C_ unused_stack_bd (hi + len v) (sz + len v) $ =
-- (named '(mpbi (sseq1 s_exsep1) @ s_eximi @ a1i @ mpbir (sseq1 s_sep_anlift2) @
--   sstr (s_anim2a @ mpbiri s_mem_dealloc_stack @ sseq2d @
--     unused_stackeq2d @ syl addsub anr) @
--   s_anim1 @ mpbir s_lift_ss @
--   anim (bi1i @ bitr leadd1 (leeq1 addass)) @ mpi leaddid1 letr));

--| The maximal layout (an upper bound on all stack layouts).
@_ local def L_top: set = $ S\ lo, S\ a, S\ sz, (^s (a + sz e. u64)) $;

theorem L_top_val: $ L_top @' lo @' a @' sz == ^s (a + sz e. u64) $ =
(focus '(trud _ @ ! eqsid $ L_top $) '(rappsabed1 @ rappsabed1 @ rappsabed2 ,eqtac));

theorem L_sstop_b: $ L C_ L_top <->
  A. lo A. a A. sz L @' lo @' a @' sz C_ ^s (a + sz e. u64) $ =
'(bitr rappssb @ aleqi @ bitr rappssb @ aleqi @ bitr rappssb @ aleqi @ sseq2 L_top_val);

theorem L_sstop: $ L C_ L_top -> L @' lo @' a @' sz C_ ^s (a + sz e. u64) $ =
'(sylib (sseq2 L_top_val) @ syl rappss @ syl rappss rappss);

--| A padding layout.
@_ local def L_pad: set = $ S\ lo, S\ a, S\ sz, (a >=>.[lo] sz) $;

theorem L_pad_val: $ L_pad @' lo @' a @' sz == a >=>.[lo] sz $ =
(focus '(trud _ @ ! eqsid $ L_pad $)
  '(rappsabed1 @ rappsabed1 @ rappsabed2 ,eqtac));

--| The null layout.
@_ local def L_with (p: wff) (L: set): set =
$ S\ lo, S\ a, S\ sz, (^s p /\s L @' lo @' a @' sz) $;

theorem L_with_val: $ L_with p L @' lo @' a @' sz == ^s p /\s L @' lo @' a @' sz $ =
(focus '(trud _ @ ! eqsid $ L_with p L $)
  '(rappsabed1 @ rappsabed1 @ rappsabed2 ,eqtac));

theorem L_with_ss2: $ L_with p L @' lo @' a @' sz C_ L @' lo @' a @' sz $ =
'(mpbir (sseq1 L_with_val) s_anr);

theorem L_with_ss: $ L_with p L C_ L $ =
(named '(mpbir rappssb @ ax_gen @ mpbir rappssb @ ax_gen @
  mpbir rappssb @ ax_gen L_with_ss2));

theorem L_with_sstop (h: $ L C_ L_top $): $ L_with p L C_ L_top $ =
(named '(sabssi @ sabssi @ sabssi @ s_anwr @ L_sstop h));

theorem L_with_sized (h: $ G -> L @' lo @' a @' sz C_ ^s (sz = n) $):
 $ G -> L_with p L @' lo @' a @' sz C_ ^s (sz = n) $ =
'(syl (sstr L_with_ss2) h);

--| The null layout.
@_ local def L_emp: set = $ S\ lo, S\ a, S\ sz, (^e (a e. u64 /\ sz = 0)) $;

theorem L_emp_val: $ L_emp @' lo @' a @' sz == ^e (a e. u64 /\ sz = 0) $ =
(focus '(trud _ @ ! eqsid $ L_emp $) '(rappsabed1 @ rappsabed1 @ rappsabed2 ,eqtac));

theorem L_emp_sstop: $ L_emp C_ L_top $ =
(named '(sabssi @ sabssi @ sabssi @ mpbir s_elift_ss_lift2 @
  impcom @ bi2d @ eleq1d @ syl6eq add0 addeq2));

theorem L_emp_sized: $ L_emp @' lo @' a @' sz C_ ^s (sz = 0) $ =
'(mpbir (sseq1 L_emp_val) @ mpbir s_elift_ss_lift2 anr);

--| A sequential composition of layouts.
@_ local def L_seq (L1 L2: set): set =
$ S\ lo, S\ a, S\ sz, (E.s sz1 e. _V, E.s sz2 e. _V,
   (^s (sz e. u64 /\ sz = sz1 + sz2) /\s
    L1 @' lo @' a @' sz1 *s L2 @' lo @' (a + sz1) @' sz2)) $;

theorem L_seq_val: $ L_seq L1 L2 @' lo @' a @' sz ==
  E.s sz1 e. _V, E.s sz2 e. _V, (^s (sz e. u64 /\ sz = sz1 + sz2) /\s
    L1 @' lo @' a @' sz1 *s L2 @' lo @' (a + sz1) @' sz2) $ =
(focus '(trud _ @ ! eqsid $ L_seq L1 L2 $)
  '(rappsabed1 @ rappsabed1 @ rappsabed2 ,eqtac));

theorem L_seq_sstop (h2: $ L2 C_ L_top $): $ L_seq L1 L2 C_ L_top $ =
(named '(sabssi @ sabssi @ sabssi @ s_eex @ s_eex @ s_imp @
  sylib (sseq1 @ eqstr3 s_sep_anlift2 @ s_sepeq2 @ mpbi s_bian1a @ L_sstop h2) @
  syl (sstr s_anl) @ sylibr s_lift_ss @ bi2d @ eleq1d @ syl6eqr addass @ addeq2d anr));

theorem L_seq_sized {sz1 sz2}
  (h1: $ G -> L1 @' lo @' a @' sz1 C_ ^s (sz1 = x) $)
  (h2: $ G -> L2 @' lo @' (a + sz1) @' sz2 C_ ^s (sz2 = y) $)
  (e: $ G -> x + y = z $):
  $ G -> L_seq L1 L2 @' lo @' a @' sz C_ ^s (sz = z) $ =
'(sylibr (sseq1 L_seq_val) @ sylib s_eexb @ ialda @ sylib s_eexb @ ialda @
  syl s_imp @ exp @ mpbid (sseq1d @ syl5eqsr s_sep_anlift @
    s_sepeqd (sylib s_bian1a @ anw3l h1) (sylib s_bian1a @ anw3l h2)) @
  syl (sstr s_anl) @ sylibr s_lift_ss @ exp @
  eqtrd (anrd anlr) @ eqtrd (addeqd anrl anrr) (anw4l e));

theorem L_seq_sized1 {sz1}
  (h: $ G -> L1 @' lo @' a @' sz1 C_ ^s (sz1 = x) $):
  $ G -> L_seq L1 L2 @' lo @' a @' sz == ^s (sz e. u64 /\ x <= sz) /\s
      L1 @' lo @' a @' x *s L2 @' lo @' (a + x) @' (sz - x) $ =
'(syl5eqs L_seq_val @
  eqstrd (!! s_exeq2d sz1 @ syl6eqs s_exan1 @ s_exeq2d @
    s_bian12d @ s_bian1sep1d @ eqscomd @ sylib s_bian1a h) @
  eqstrd (s_exeqe2 ,eqtac) @
  syl5eqsr s_exan1 @
  eqstr3d (!! s_exeq2d sz2 @ eqstr3g s_anliftass s_anliftass @ s_aneq1d @ s_lifteqd @
    syl6bbr (bian1 elv) @
    a1i @ bian1a @ eqcomd @ syl6eq pncan2 @ subeq1d anr) @
  eqstrd (s_exeqe2 ,eqtac) @ a1i @
  eqstr3 s_anliftass @ s_aneq1 @ s_lifteq @
  bitr (aneq2i @ aneq2i @ ibii (mpbiri leaddid1 leeq2) @ eqcomd pncan3) @
  bian1 elv);

theorem L_seq_sized2 {sz1 sz2}
  (h: $ G /\ sz = sz1 + sz2 -> L2 @' lo @' (a + sz1) @' sz2 C_ ^s (sz2 = x) $):
  $ G -> L_seq L1 L2 @' lo @' a @' sz == ^s (sz e. u64 /\ x <= sz) /\s
      L1 @' lo @' a @' (sz - x) *s L2 @' lo @' (a + (sz - x)) @' x $ =
'(syl5eqs L_seq_val @
  eqstrd (!! s_exeq2d sz1 @
    eqstrd (!! s_exeq2d sz2 @ s_bian12da @ s_bian1sep2d @
      eqscomd @ sylib s_bian1a @ rsyl (anim2 anr) h) @
    eqstr4d (s_exeqe2 ,eqtac) @
    eqstr3g s_anliftass s_anliftass @ s_aneq1d @ s_lifteqd @
    syl6bbr (bian1 elv) @
    a1i @ bian1a @ eqcomd @ syl6eq pncan @ subeq1d anr) @
  eqstrd (s_exeqe2 ,eqtac) @ a1i @
  eqstr3 s_anliftass @ s_aneq1 @ s_lifteq @
  bitr (aneq2i @ aneq2i @ ibii (mpbiri leaddid2 leeq2) @ eqcomd npcan) @
  bian1 elv);

theorem L_seq_ss: $ L11 C_ L12 -> L21 C_ L22 -> L_seq L11 L21 C_ L_seq L12 L22 $ =
(named '(exp @ sabssd @ sabssd @ sabssd @ s_eximd @ s_eximd @
  syl s_anim2 @ sylc s_sepim
    (syl rappss @ syl rappss @ syl rappss an3l)
    (syl rappss @ syl rappss @ syl rappss anllr)));

theorem L_seq_emp: $ L C_ L_top -> L_seq L L_emp == L $ =
(named '(sylibr eqrappb @ iald @ sylibr eqrappb @ iald @ sylibr eqrappb @ iald @
  eqstrd (L_seq_sized2 @ a1i L_emp_sized) @
  eqstrd (s_aneq2d @ syl6eqs s_sep_elift @
    s_sepeqd (a1i @ rappeq2 sub02) (a1i L_emp_val)) @
  syl5eqsr s_anliftass @ sylib s_bian1a @
  syl (mpi (mpbir s_lift_ss @ iand (iand (u64le1 leaddid2) @ a1i le01) @
    iand (bi2i @ eleq1 @ addeq2 sub02) eqidd) sstr) L_sstop));

theorem L_emp_seq: $ L C_ L_top -> L_seq L_emp L == L $ =
(named '(sylibr eqrappb @ iald @ sylibr eqrappb @ iald @ sylibr eqrappb @ iald @
  eqstrd (L_seq_sized1 @ a1i L_emp_sized) @
  eqstrd (s_aneq2d @ syl6eqs s_elift_sep @
    s_sepeqd (a1i L_emp_val) @ a1i @ rappeq (rappeq2 add0) sub02) @
  syl5eqsr s_anliftass @ sylib s_bian1a @
  syl (mpi (mpbir s_lift_ss @ iand (iand (u64le1 leaddid2) @ a1i le01) @
    iand (u64le1 leaddid1) eqidd) sstr) L_sstop));

theorem L_seqass: $ L_seq (L_seq L1 L2) L3 == L_seq L1 (L_seq L2 L3) $ =
(named '(sabeqi @ sabeqi @ !! sabeqi sz @
  eqstr4 (s_biexexi @ s_biexexi @ s_biexan2i @ s_biexsep1i @ !! L_seq_val sz1 sz2) @ !! s_exeq2i sz1 @
  eqstr4 (s_biexexi @ s_biexan2i @ s_biexsep2i @ !! L_seq_val sz2 sz3) @
  eqstr4 (s_biexexi @ s_biexexi @ s_biexan2i @ s_biexsep1i eqsid) @ !! s_exeq2i sz2 @
  eqstr4 (s_biexexi @ s_biexan2i @ s_biexsep2i eqsid) @ eqstr4 s_excom @ !! s_exeq2i sz3 @
  eqstr (s_exeq2i @ s_bian12i @ s_bian1sep2i @ eqstr s_anliftass s_anliftlass) @
  eqstr4 (trud @ s_exeqe2 ,eqtac) @
  eqstr (s_exeq2i @ s_bian12i @ s_bian1sep1i @ eqstr s_anliftass s_anliftlass) @
  eqstr4 (trud @ s_exeqe2 ,eqtac) @
  eqstr4 (eqstr3 s_anliftass @ eqstr4 (s_aneq2 @ s_bian1sep2i eqsid) s_anliftass) @
  eqstr4 (eqstr3 s_anliftass @ eqstr4 (s_aneq2 @ s_bian1sep1i eqsid) s_anliftass) @
  s_aneq (s_lifteq @
    bitr4 (bian2a @ anwr @ impcom @ syl u64le1 @ mpbiri leaddid2 leeq2) @
    bitr4 (bian2a @ anwr @ impcom @ syl u64le1 @ mpbiri leaddid1 leeq2) @
    bitr4 (bian1 elv) @ bitr (bian1 elv) @
    aneq2i @ eqeq2 addass) @
  eqstr3 s_sepass @ s_sepeq2 @ rappeq1 @ rappeq2 addass));

--| The layout for a single value `v: List u8`.
@_ local def L_1 (v: nat): set =
$ S\ lo, S\ a, S\ sz, (^s (lo + 2 ^ 12 <= a /\ sz = len v) /\s a >=> v) $;

theorem L_1_val: $ L_1 v @' lo @' a @' sz == ^s (lo + 2 ^ 12 <= a /\ sz = len v) /\s a >=> v $ =
(focus '(trud _ @ ! eqsid $ L_1 v $)
  '(rappsabed1 @ rappsabed1 @ rappsabed2 ,eqtac));

theorem L_1_drop: $ L_1 v C_ L_pad $ =
(named '(sabssi @ sabssi @ sabssi @
  s_imp @ mpbird (sseq2d @ s_blockSeq3d anr) @ anwl s_block_blockS));

theorem L_1_sized: $ L_1 v @' lo @' a @' sz C_ ^s (sz = len v) $ =
'(mpbir (sseq1 L_1_val) @ s_anwl @ mpbir s_lift_ss anr);

theorem L_1_sstop: $ L_1 v C_ L_top $ =
(named '(sabssi @ sabssi @ sabssi @ s_imp @ syl (sstr s_block_T) @
  sylibr s_lift_ss @ syl5 anl @ bi2d @ eleq1d @ addeq2d anr));

theorem L_pad_sstop: $ L_pad C_ L_top $ =
(named '(sabssi @ sabssi @ sabssi s_blockS_T));

theorem L_pad_seq: $ L_seq L_pad L_pad == L_pad $ =
(named '(sabeqi @ sabeqi @ sabeqi @
  eqstr (s_exeq2i @ s_exeq2i @ s_aneq2 @ s_sepeq L_pad_val L_pad_val) @
  ssasym (s_eex @ s_eex @
    mpbi (sseq1 @ s_aneq2a @ anwr @ syl6eqs s_blockS_A s_blockSeq3) s_anr) @
  mpbi (sseq1 @ mpbi s_bian1a s_blockS_T) @ s_imp @
  syl s_iex @ !! iexde x @ iand (a1i elv) @
  syl s_iex @ !! iexde y @ iand (a1i elv) @
  syl eqssr @ eqstrd (syl (s_bian1 s_sep_sstop) @
    iand (anwll @ u64le1 leaddid2) @ eqcomd @ syl6eq add0 ,eqtac) @
  syl5eqsr s_blockS_A @ s_blockSeq3d @ syl6eq add0 ,eqtac));

--| An overlapping composition of layouts.
@_ local def L_or (L1 L2: set): set =
$ S\ lo, S\ a, S\ sz, (E.s sz1 e. u64, E.s sz2 e. u64,
   (^s (sz = max sz1 sz2) /\s
    (L1 @' lo @' a @' sz1 *s L_pad @' lo @' (a + sz1) @' (sz - sz1) \/s
     L2 @' lo @' a @' sz2 *s L_pad @' lo @' (a + sz2) @' (sz - sz2)))) $;

theorem L_or_val: $ L_or L1 L2 @' lo @' a @' sz ==
  E.s sz1 e. u64, E.s sz2 e. u64, (^s (sz = max sz1 sz2) /\s
    (L1 @' lo @' a @' sz1 *s L_pad @' lo @' (a + sz1) @' (sz - sz1) \/s
     L2 @' lo @' a @' sz2 *s L_pad @' lo @' (a + sz2) @' (sz - sz2))) $ =
(focus '(trud _ @ ! eqsid $ L_or L1 L2 $)
  '(rappsabed1 @ rappsabed1 @ rappsabed2 ,eqtac));

theorem L_or_sstop (h1: $ L1 C_ L_top $) (h2: $ L2 C_ L_top $): $ L_or L1 L2 C_ L_top $ =
(named
  (def (f x) '(syl s_sepssr @ mpbii (L_sstop L_pad_sstop) @
    sseq2d @ s_lifteqd @ eleq1d @ syl5eq addass @ addeq2d @ syl pncan3 @
    mpbiri ,x leeq2))
  '(sabssi @ sabssi @ sabssi @ s_eex @ s_eex @ s_imp @
    sylc s_eor ,(f 'lemax1) ,(f 'lemax2)));

--| An overlapping composition of layouts.
@_ local def stack_layout (sp n: nat) (L: set): set =
$ E.s lo e. _V, E.s sz e. _V, (
    ^s (lo + sz e. u64 /\ sp <= lo + sz /\ lo + 2 ^ 12 + n <= lo + sz) /\s
    RSP >->r (lo + sz - sp) *s L_seq L_pad L @' lo @' lo @' sz) $;

--| The portion of the layout that we always want to know in any hoare triple.
--| `main_layout c sp ip` means that the code `c` is at `text_start`,
--| the instruction pointer at `ip`, and the flags are assigned to an arbitrary value
--| (i.e. we are permitted to clobber them).
--| Additionally, the stack is laid out according to stack layout `L`
--| (see the `L_*` functions) with at least `n` spare bytes left in the stack frame;
--| `sp` is the value of the stack pointer relative to the stack layout.
@_ local def main_layout (c sp ip n L): set =
$ text_start >=>c c *s RIP>-> ip *s s_OK *s flags>->. *s stack_layout sp n L $;

--| The correctness predicate for a function call.
--| * `T`: A global parameter, the correctness predicate on final IO
--| * `c`: A global parameter, the program code
--| * `ip`: The address of the function
--| * `P`: The function's precondition, arranged using a calling convention
--| * `Q`: The function's postcondition, also determined by a calling convention
--|
--| This says that if we were to call a function at location `ip`,
--| with inputs arranged according to `P`, then the function will successfully
--| terminate and the outputs will be arranged according to `Q`.
--|
--| Both `P` and `Q` are allowed to depend on common logical variables `vs`.
@_ local def func_ok (T c ip P Q): wff =
$ A. vs A. ret (ret e. u64 -> hoare T
    (main_layout c 8 ip (2 ^ 12) (L_1 (u64Bytes ret)) *s (P @' vs))
    (main_layout c 0 ret 8 L_emp *s (Q @' vs))) $;

--| The correctness predicate for a jump target.
--| * `T, c`: Global parameters
--| * `sp`: The value of the stack pointer (a function-global parameter)
--| * `fr`: The frame condition (a function-global parameter)
--| * `ip`: The address of the jump target
--| * `L`: The stack frame layout as of the jump
--| * `P`: The jump's precondition, arranged using a calling convention
--|
--| This says that if we were to jump to location `ip`,
--| with inputs arranged according to `L` and `P`, then the
--| program will eventually terminate. This is used as an available
--| hypothesis for every jump target in scope.
--|
--| Both `L` and `P` are allowed to depend on common logical variables `vs`.
@_ local def jump_ok (T c sp fr ip L P): wff =
$ s_ok (sn fr *s (main_layout c sp ip 8 L *s P)) T $;

theorem stack_dealloc
  (h2: $ G -> jump_ok T c sp fr ip L2 P $)
  (h1: $ G -> L_seq L_pad L1 C_ L_seq L_pad L2 $):
  $ G -> jump_ok T c sp fr ip L1 P $ =
(named '(mpd h2 @ syl hoare_frame_E @ syl hoare_frame_r @ syl hoare_frame @
  syl hoare_exim @ ialda @ syl hoare_exim @ ialda @
  hoare_animd anr @ anw3l @ syl hoare_frame @ syl hoare_weak @
  syl ss_s_weak @ syl rappss @ syl rappss @ syl rappss h1));

theorem ret_ok
  (hc: $ assembled c (s1 (ch xc x3)) ip ip2 $)
  (hr: $ G -> ret e. u64 $)
  (hj: $ G -> jump_ok T c 0 fr ret L_emp P $):
  $ G -> jump_ok T c 8 fr ip (L_1 (u64Bytes ret)) P $ =
(named @ focus
  (have 'H '(s_code_assembled hc))
  '(mpd (stack_dealloc hj @ a1i @
      mpbi (sseq2 @ eqstr4 L_pad_seq @ L_seq_emp L_pad_sstop) @ L_seq_ss ssid L_1_drop) @
    syl hoare_frame_E @ syl hoare_frame_r @
    sylibr (hoareeq2 @ s_bisep11i @ s_bisep11i @ eqstr s_sepass s_sepcom) @
    hoare_decode_step (a1i @ s_sepwl @ s_sepwl @ anli H) (a1i decodeRet0I) (a1i @ anri H) @
    hoareCfgeq4g
      (eqstr s_sepass @ eqstr3 (s_sepeq2 s_sepass) s_seplass)
      (s_bisep11i @ eqstr (s_sepeq1 @ eqstr s_sepcom @
        eqstr4 (s_sepeq2 s_sepcom) s_sepass) @ eqstr s_sepass s_seprass) @
    syl hoareCfg_frame @
    hoareCfgeq3g s_exsep1 s_exsep1 @ sylib hoareCfg_eexb @ !! iald lo @ a1d @
    sylib (hoareCfgeq3 s_exsep1) @ sylib hoareCfg_eexb @ !! iald sz @ a1d @
    hoareCfg_iexe ,eqtac (a1i elv) @
    sylib (hoareCfgeq4 s_exsep1) @ hoareCfg_iexe ,eqtac (a1i elv) @
    hoareCfgeq4g (eqstr s_sep_anlift2 @ eqstr4 (s_aneq2 _) s_anliftass) s_sep_anlift2 _)
  (have 'H2 '(trud @ L_seq_sized2 @ a1i L_1_sized))
  (have 'H3 '(syl npcan @ anwr anllr))
  '(s_bian1sep2i @ s_bian1sep2i @ eqscom @ mpbi s_bian1a @
    mpbir (sseq1 H2) @ s_anwl @ mpbir s_lift_ss @ sylib (leeq1 u64Bytes_len) anr)
  '(hoareCfg_animd (rsyl anrl @ anim1 @ anim2 @ a1i le01) @
    hoareCfgeq3g (eqstr s_sepass s_seplass) (eqstr s_sepass s_seplass) @
    hoareCfg_xastRet0 (anwl hr)
      (sylibr (s_weakeq1 H2) @ syl s_weak_anwr @
        syl s_sepwr @ sylibr (s_weakeq1 L_1_val) @
        mpbiri s_weak_anr @ s_weakeq2d @
        s_blockeq1d @ syl eqsub1 @ syl5eq addass @ addeq2d @
        syl5eq (addeq1 @ subeq2 u64Bytes_len) @ syl npcan anrr) @
    syl6eqr sub02 @ eqtrd (syl add64_eqid @ mpbird (eleq1d H3) @ anwr an3l) H3));

-- theorem add_rsp_ok
--   (hc: $ assembled c (s1 (ch xc x3)) ip ip2 $)
--   (hr: $ G -> ret e. u64 $)
--   (hj: $ G -> jump_ok T c b fr ret L P $):
--   $ G -> jump_ok T c a fr ip L P $ =
-- _;

-- @_ local def c_param (T: set) (c fr: nat) = $ Sum T (c <> fr) $;
-- @_ local def c_param_T (X: set) = $ Fst X $;
-- @_ local def c_param_c (X: set) = $ fst (lower (Snd X)) $;
-- @_ local def c_param_fr (X: set) = $ snd (lower (Snd X)) $;

-- local def compile_expr
--   (T: set) (c fr: nat) -- global parameters
--   (ip: nat) -- the current location of the instruction pointer
--   (L: set) -- the stack layout at this point
--   (P: set) = -- the precondition for flow into this point
-- $ s_ok (sn fr *s (main_layout c sp ip 8 L *s P)) T $;

-- A type ty consists of:
-- * a separating proposition [v : ty] which gives truth conditions for "v has type ty",
-- * a proposition `v e. |ty|` which describes the "duplicable core" of the type
-- * a set of values {v : ty} which gives the valid byte strings that can represent v.
--
-- A type may have no valid byte strings, in which case it is only usable for
-- ghost values.
-- The size of a type is the smallest `n` such that `A. l (l e. {v : ty} -> len l <= n)`.

@_ local def core_of (ty: set): set = $ {v | 0 e. Fst (ty @' v)} $;
@_ local def has_ty (v: nat) (ty: set): set =
$ ^s (v e. core_of ty) /\s Tail (Fst (ty @' v)) $;
@_ local def ty_Rep (v: nat) (ty: set): set = $ Snd (ty @' v) $;
@_ local def ty_rep (ty: set) (v l: nat): set =
$ ^s (l e. ty_Rep v ty) /\s has_ty v ty $;

--| An assignment of register `r` to value `v` of type `ty`.
@_ local def t_reg (r v: nat) (ty: set): set =
$ E.s n e. upto (suc 8), E.s a e. Bits (8 * n), (
  ^s (n <= 8) /\s r >->r a *s
  ty_rep ty v (toBytes n a)) $;

--| A memory allocation at `a` with value `v` of type `ty`.
@_ local def t_mem (a v: nat) (ty: set): set =
$ E.s l e. List u8, (a >=> l *s ty_rep ty v l) $;

@_ local def ty_u8: set = $ S\ v, Sum (ocasep (v e. u8) emp) (sn (v : 0)) $;
@_ local def ty_u16: set = $ S\ v, Sum (ocasep (v e. u16) emp) (sn (u16Bytes v)) $;
@_ local def ty_u32: set = $ S\ v, Sum (ocasep (v e. u32) emp) (sn (u32Bytes v)) $;
@_ local def ty_u64: set = $ S\ v, Sum (ocasep (v e. u64) emp) (sn (u64Bytes v)) $;
@_ local def ty_i8: set = $ S\ v, Sum (ocasep (v e. u8) emp) (sn (i8Bytes v)) $;
@_ local def ty_i16: set = $ S\ v, Sum (ocasep (v e. u16) emp) (sn (i16Bytes v)) $;
@_ local def ty_i32: set = $ S\ v, Sum (ocasep (v e. u32) emp) (sn (i32Bytes v)) $;
@_ local def ty_i64: set = $ S\ v, Sum (ocasep (v e. u64) emp) (sn (i64Bytes v)) $;
@_ local def ty_nat: set = $ S\ v, Sum (ocasep T. emp) 0 $;
@_ local def ty_int: set = $ S\ v, Sum (ocasep T. emp) 0 $;

--| The "duplicable core" of a type.
@_ local def ty_core (ty: set): set =
$ S\ v, Sum (ocasep (v e. core_of ty) emp) (ty_Rep v ty) $;

--| A singleton has the same representation as the underlying type, but
--| it only has one valid value.
@_ local def ty_sn (a: nat) (ty: set): set =
$ S\ v, Sum (ocasep (v = a /\ v e. core_of ty) (has_ty v ty)) (ty_Rep v ty) $;

-------------------------------------
-- Eliminating the bound variables --
-------------------------------------

--| The separating conjunction lifted over functions on `vs`.
@_ local def v_sep (P Q): set = $ S\ vs, (P @' vs *s Q @' vs) $;

@_ local def trim0 (n: nat): nat = $ lower ((\ i, n @ i) i^i Xp (Compl (sn 0)) _V) $;

--| The `n`th variable as a higher order function from the variable list to a value.
@_ local def vn (n: nat): set = $ \ vs, vs @ n $;

--| An assignment of register `r` to value `v` of type `ty`.
local def v_reg (r: hex) (v ty: set): set = $ S\ vs, t_reg r (v @ vs) (ty @' vs) $;

--| A memory allocation at `a` with value `v` of type `ty`.
@_ local def v_mem (a: nat) (v ty: set): set = $ S\ vs, t_mem a (v @ vs) (ty @' vs) $;

--| Asserts that the expression `v` has type `ty`.
@_ local def v_has_ty (v ty: set): set = $ S\ vs, has_ty (v @ vs) (ty @' vs) $;

--| Lift the singleton type to functions.
@_ local def v_ty_sn (a ty: set): set = $ S\ vs, ty_sn (a @ vs) (ty @' vs) $;

--| Lift addition to functions.
@_ local def v_add (a b: set): set = $ \ vs, a @ vs + b @ vs $;

--| Existential quantifier expressed without bound variables.
--| `v_ex i ty P` means there exists `v_i` such that `[v_i : ty] *s P[i/v_i]`.
--| Note that we are using explicit (named) variables here, not de Bruijn;
--| we clobber the previous value of `v_i` inside the scope.
@_ local def v_ex (i: nat) (ty P: set): set =
$ S\ vs, (E.s a e. _V, (has_ty a ty *s
  P @' trim0 (lower (write vs i a)))) $;

@_ local def v_ty_u32: set = $ S\ vs, ty_u32 $;

-- testing

-- local def progT = $ S\ i, {o | 2 + 2 = 4} $;
-- local def prog: string = $s0$;
-- local def adder: nat = $0$;

-- theorem th (vs)
--   (hc: $ assembled prog (s1 (ch xc x3)) ip ip2 $)
--   (h1: $ G -> ret e. u64 $)
--   (h2: $ G -> jump_ok progT prog 0 fr ret L_emp
--     (v_ex x2
--         (v_ty_sn (v_add (vn x0) (vn x1)) v_ty_u64)
--         (v_reg x0 (vn x2) (v_ty_sn (v_add (vn x0) (vn x1)) v_ty_u64)) @'
--       vs) $):
--   $ G -> s_ok
--     (sn fr *s
--       (main_layout prog 8 adder (2 ^ 12) (L_1 (toBytes 8 ret)) *s
--         v_sep (v_reg x7 (vn x0) v_ty_u32) (v_reg x6 (vn x1) v_ty_u32) @' vs))
--     progT $ =
-- (focus
--   (have 'h '(ret_ok hc h1 h2))
--   );
-- theorem _:
--   $ func_ok progT prog adder
--       (v_sep
--         (v_reg x7 (vn x0) v_ty_u32)
--         (v_reg x6 (vn x1) v_ty_u32))
--       (v_ex x2 (v_ty_sn (v_add (vn x0) (vn x1)) v_ty_u64)
--         (v_reg x0 (vn x2) (v_ty_sn (v_add (vn x0) (vn x1)) v_ty_u64))) $ =
-- (named '(ax_gen @ ax_gen @ ialda @ th _ anl anr));

-- (proc (adder {x : u32} {y : u32} : {ret : (sn {{x + y} : u64})})
--   (cast {(cast {x + y} (assert {{x + y} < {2 ^ 64}})) : u64}))
--
-- (proc (main : $ 2 + 2 = 4 $)
--   {(four h) := (adder 2 2)}
--   -- h: $ 2 + 2 = four $
--   {h2 := (assert {four = 4})}
--   -- h: $ 2 + 2 = four $, h2: $ four = 4 $
--   (return (entail h h2 eqtr)))

--| Constructs a cons of 16 elements represented as a perfect binary tree in `a`.
--| We use `cons16` nodes for storing lists of variable values with efficient lookup
--| (still linear time but with a better constant factor). Most functions won't have
--| more than 60-100 variables anyway so this should be fine, and if we need to do
--| better it's possible to make this logarithmic using binary random-access lists.
@_ local def cons16 (a l: nat): set =
$ ,(letrec ([(f n a x)
    @ if {n = 0} '(cons ,a ,x) (f {n - 1} '(fst ,a) @ f {n - 1} '(snd ,a) x)])
    (f 4 'a 'l)) $;

do {
  (def mmc-compiler (ref! (mmc-init)))
  (def mmc-reset
    (def c mmc-compiler)
    (fn () (set! c (mmc-init))))
  (def mmc-add
    (def c mmc-compiler)
    (fn xs (apply c '+ xs)))
  (def mmc-finish
    (def c mmc-compiler)
    (fn xs (apply c 'finish xs)))
  (def mmc-compiler)
  (def (mmc-compile x . xs)
    (apply mmc-add xs)
    (mmc-finish x))
};
